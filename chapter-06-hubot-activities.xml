<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>CoffeeScript, Hubot, and the Activity API</title>
<date>2018-11-09</date>
</info>
<section xml:id="Hubot">
<title>CoffeeScript, Hubot, and the Activity API</title>
<simpara>Though the phrase has now been removed from its marketing materials,
GitHub used to call itself a tool for "social coding." This idea is
still central to the services GitHub provides&#x2014;intimate access to the
social layer inside of GitHub through the Activity API.</simpara>
<simpara><indexterm>
<primary>Hubot</primary><secondary>id=ix_chapter-06-hubot-activities-asciidoc0</secondary><tertiary>range=startofrange</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc0</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm>In this chapter we&#8217;ll investigate the Activity API by extending a chat
robot. You might find it odd that a robot, generally considered an antisocial
invention despite all best attempts, would play nicely with a social
API, but this is a social robot. GitHubbers use an
extensible chat robot called Hubot to record and automate their tasks,
and to have fun on the Internet. If there were any robot suited for
interacting with the GitHub Activity API, it&#8217;s Hubot, described on the
site <link xl:href="https://hubot.github.com/">https://hubot.github.com/</link> as "a customizable, kegerator-powered life
embetterment robot."</simpara>
<section xml:id="_the_activity_api">
<title>The Activity API</title>
<simpara><indexterm>
<primary>Activity API</primary><secondary>contents of</secondary>
</indexterm>
<indexterm>
<primary>contents of</primary>
</indexterm>The Activity API includes:</simpara>
<itemizedlist>
<listitem>
<simpara>Notifications (comments issued to users through various events)</simpara>
</listitem>
<listitem>
<simpara>Stargazing tools (Facebook has "likes" while GitHub has "stars" to indicate approval or interest)</simpara>
</listitem>
<listitem>
<simpara>Watching (a way to track GitHub data)</simpara>
</listitem>
<listitem>
<simpara>Events (a higher-level activity stream useful for following actions of users)</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The Activity API section also includes<indexterm>
<primary>feeds</primary>
</indexterm> <emphasis>feeds</emphasis>. While feeds are
grouped within the Activity API, they are not programmatic in the same
way an API is, and we won&#8217;t cover them in depth here. Feeds are
actually Atom feeds and not interactive beyond that. Atom feeds are
similar to RSS feeds: a static feed you can subscribe to with an Atom
client.</simpara>
</note>
</section>
<section xml:id="_planning_for_pr_satisfaction_guaranteed">
<title>Planning for PR Satisfaction Guaranteed</title>
<simpara><indexterm>
<primary>Hubot</primary><secondary>capabilities of</secondary>
</indexterm>
<indexterm>
<primary>capabilities of</primary>
</indexterm>We are going to build an extension to Hubot. When we are done, Hubot
will be transformed into a robot that&#8230;&#8203;</simpara>
<itemizedlist>
<listitem>
<simpara>listens for pull request events from GitHub by subscribing to
notifications using the GitHub Activity API;</simpara>
</listitem>
<listitem>
<simpara>invites people in the chat room to comment on those pull requests;</simpara>
</listitem>
<listitem>
<simpara>guarantees that communication between it and GitHub is securely
delivered (with an unfortunate bug as caveat);</simpara>
</listitem>
<listitem>
<simpara>retrieves vital information from an external service (the Slack API);</simpara>
</listitem>
<listitem>
<simpara>has functionality fully described by automated tests;</simpara>
</listitem>
<listitem>
<simpara>allows easy simulation of inputs and outputs that map to the
inputs and outputs it gets from APIs and services; and</simpara>
</listitem>
<listitem>
<simpara>runs with ease on a major PaaS (Heroku).</simpara>
</listitem>
</itemizedlist>
<simpara>Hubot provides the skeleton for our chat robot. We&#8217;ll add the preceding
functionality to Hubot and see how easy it is to combine these
features into a coherent whole that solves a real problem.</simpara>
<section xml:id="_considerations_and_limitations">
<title>Considerations and Limitations</title>
<simpara><indexterm>
<primary>Hubot</primary><secondary>considerations and limitations</secondary>
</indexterm>
<indexterm>
<primary>considerations and limitations</primary>
</indexterm>If you want stability with your Hubot, you need to host it on a
server. Hubot is written in NodeJS and requires a hosting service that
supports NodeJS. Our Hubot needs to sit on a public IP address (not
inside the firewall) because we receive notifications from GitHub. It
is not strictly required that you host Hubot on a public server; if
your Hubot does not need to receive requests from the outside world,
you can host on a private internal server as well.</simpara>
<simpara><indexterm>
<primary>Heroku</primary><secondary>Hubot and</secondary>
</indexterm>
<indexterm>
<primary>Hubot and</primary>
</indexterm>The simplest and cheapest hosting service for Hubot is Heroku. Once we
generate our Hubot, we can simply do a git-push into Heroku to publish
our chat robot for free. We&#8217;ll show these steps later in the chapter.</simpara>
<simpara>Hubot works with many chat endpoints. Your Hubot can connect to almost
any popular chat service or protocol: IRC, XMPP, and many commercial
services like Gchat, Basecamp, and even Twitter. Slack is a relatively new
entrant into the world of chat services, but despite its youth, the
Slack API is solid and connecting third-party clients to the Slack
service is simple and straightforward. We&#8217;ll use Slack as our chat endpoint.</simpara>
<simpara>Now let&#8217;s create our Hubot and configure it to use Slack.</simpara>
</section>
<section xml:id="_creating_a_vanilla_hubot">
<title>Creating a Vanilla Hubot</title>
<simpara><indexterm>
<primary>Hubot</primary><secondary>basic</secondary>
</indexterm>
<indexterm>
<primary>basic</primary>
</indexterm><indexterm>
<primary>NodeJS</primary><secondary>and Hubot</secondary>
</indexterm>
<indexterm>
<primary>and Hubot</primary>
</indexterm>To build a Hubot you will need a working NodeJS installation, as
specified in <xref linkend="appendix"/>. The following commands create a
directory with a barebones Hubot:</simpara>
<screen>$ npm install -g generator-hubot <co xml:id="CO1-1"/>
$ mkdir slacker-hubot <co xml:id="CO1-2"/>
$ cd slacker-hubot/
$ yo hubot <co xml:id="CO1-3"/>
$ npm install hubot-slack --save <co xml:id="CO1-4"/></screen>
<simpara>You may not be familiar with these commands, so let&#8217;s go over the
important ones.</simpara>
<calloutlist>
<callout arearefs="CO1-1">
<para>npm is the tool that installs packages for NodeJS (documented in
<xref linkend="appendix"/>). The <literal>npm install -g
generator-hubot</literal> command installs a command-line tool called yeoman
and a plug-in for yeoman that scaffolds Hubot.</para>
</callout>
<callout arearefs="CO1-2">
<para>You should create a new directory and enter it so that when you
create your Hubot you can store it entirely in its own space.</para>
</callout>
<callout arearefs="CO1-3">
<para>You run the generator using the <literal>yo hubot</literal> command. This builds
out the set of files for a minimal Hubot.</para>
</callout>
<callout arearefs="CO1-4">
<para>We then install the slack adapter and save the package to the
<emphasis>package.json</emphasis> file.</para>
</callout>
</calloutlist>
<simpara>Now that we have a simple Hubot created we need to create the Slack site
where our Hubot will live.</simpara>
</section>
<section xml:id="_creating_a_slack_account">
<title>Creating a Slack Account</title>
<simpara><indexterm>
<primary>Hubot</primary><secondary>Slack account for</secondary><tertiary>id=ix_chapter-06-hubot-activities-asciidoc1</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc1</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm><indexterm>
<primary>Slack</primary><secondary>id=ix_chapter-06-hubot-activities-asciidoc2</secondary><tertiary>range=startofrange</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc2</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm>Going to <link xl:href="https://slack.com/">https://slack.com/</link> starts the process of creating your own Slack
site. You&#8217;ll need to step through creating an account. Slack sites are
segmented by organization, and you&#8217;ll want to establish a URL prefix
for your Slack site. Typically this is the name of your organization.</simpara>
<section xml:id="_naming_the_channel">
<title>Naming the channel</title>
<simpara><indexterm>
<primary>Hubot</primary><secondary>channel creation</secondary><tertiary>id=ix_chapter-06-hubot-activities-asciidoc3</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc3</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm>Once you have your slack site created, you need to create a channel as in <xref linkend="creating_a_channel_from_the_slack_sidebar"/>.</simpara>
<figure xml:id="creating_a_channel_from_the_slack_sidebar">
<title>Creating a channel from the Slack sidebar</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/btwg_08in01.png"/>
</imageobject>
<textobject><phrase>btwg 08in01</phrase></textobject>
</mediaobject>
</figure>
<simpara>You can name the channel anything you want, but it is often a good
mnemonic to use a name that suggests this is a channel where more
serious work gets done. You could use a name like "PR Discussion" to
indicate this is the channel where PRs are discussed. To keep things
simple, we will use the name "#general." Once you click
the link to create a channel, you&#8217;ll see a popup asking for the name
and an optional description. After you have created the channel,
you will see a link to "Add a service integration" as shown in <xref linkend="adding_service_integrations_to_slack"/>.</simpara>
<figure xml:id="adding_service_integrations_to_slack">
<title>Adding service integrations to Slack</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/btwg_08in02.png"/>
</imageobject>
<textobject><phrase>btwg 08in02</phrase></textobject>
</mediaobject>
</figure>
<simpara>Slack supports many different service integrations, and one of them is
Hubot as shown in <xref linkend="service_integration_options_for_slack"/>.</simpara>
<figure xml:id="service_integration_options_for_slack">
<title>Service integration options for Slack</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/btwg_08in03.png"/>
</imageobject>
<textobject><phrase>btwg 08in03</phrase></textobject>
</mediaobject>
</figure>
<simpara>Choosing Hubot takes you to a settings screen for your Hubot integration.</simpara>
<simpara>Slack automatically generates an authentication token for you.
This token is used to verify the connection from your Hubot. This
token can be revoked, and in fact the token from <xref linkend="choose_hubots_name"/>
has been revoked and can no longer be used to authenticate into
Slack. If you ever accidentally publicize this token, you can easily
revoke and reassign a token to your Hubot on this screen.</simpara>
<simpara>You will also need to specify a name. Use "probot" and if you&#8217;d like,
change the avatar associated with the Hubot (these options are shown in <xref linkend="choose_hubots_name"/>).</simpara>
<figure xml:id="choose_hubots_name">
<title>Hubot configuration page for Slack</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/btwg_08in04.png"/>
</imageobject>
<textobject><phrase>btwg 08in04</phrase></textobject>
</mediaobject>
</figure>
<simpara>Make sure you save your integration before continuing<indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc3</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc3</primary>
</indexterm>.<indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc2</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc2</primary>
</indexterm><indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc1</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc1</primary>
</indexterm></simpara>
</section>
</section>
<section xml:id="_running_hubot_locally">
<title>Running Hubot Locally</title>
<simpara><indexterm>
<primary>Hubot</primary><secondary>running locally</secondary>
</indexterm>
<indexterm>
<primary>running locally</primary>
</indexterm>Eventually you will want to run your Hubot on a server, but Hubot can
run from a laptop behind a firewall as well. At the beginning of
development, while testing and developing your bot and the changes are
fast and furious, you probably want to run Hubot
locally. In fact, Hubot behind a firewall is almost identical in its
feature set with one major exception: anything behind the firewall is
inaccessible, obviously, to external services. We are eventually going
to be configuring GitHub to send events to us when a pull request is
created, and Hubot behind the firewall cannot receive those
events. But, for almost all other functionality, running Hubot locally
speeds up development cadence.</simpara>
<simpara role="pagebreak-before">To run your bot locally, make sure you specify the variables on
the command line:</simpara>
<screen>$ HUBOT_SLACK_TOKEN=xoxb-3295776784-nZxl1H3nyLsVcgdD29r1PZCq \
./bin/hubot -a slack</screen>
<simpara>This command runs the Hubot script with the Slack adapter. The Slack adapter
knows how to interact with the Slack.com service. It requires an
authentication token, and this is provided via the environment
variable at the beginning of the line.</simpara>
<section xml:id="_a_first_conversation">
<title>A first conversation</title>
<simpara><indexterm>
<primary>Hubot</primary><secondary>first conversation</secondary>
</indexterm>
<indexterm>
<primary>first conversation</primary>
</indexterm>Your bot should be set up and waiting in the #general room inside your
Slack site. Go to the #general room. Then, you can test that Hubot
is properly connectd by typing in the name of your Hubot
and then a command like <literal>the rules</literal>. For example, if our Hubot is
named probot, then we would type <literal>probot the rules</literal>, which then displays the following conversation as shown in <xref linkend="hubots_built_in_repartee"/>.</simpara>
<figure xml:id="hubots_built_in_repartee">
<title>Hubot&#8217;s built-in repartee</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/btwg_08in05.png"/>
</imageobject>
<textobject><phrase>btwg 08in05</phrase></textobject>
</mediaobject>
</figure>
<simpara>We see that our Hubot printed out the rules it
abides by (published originally by Isaac Asimov in his "Runaround"
short story in 1942).</simpara>
</section>
<section xml:id="_exploring_the_hubot_vocabulary">
<title>Exploring the Hubot vocabulary</title>
<simpara><indexterm>
<primary>Hubot</primary><secondary>exploring vocabulary of</secondary>
</indexterm>
<indexterm>
<primary>exploring vocabulary of</primary>
</indexterm>Hubot out-of-the-box supports many commands. To get a list, type help to see a list like that shown in <xref linkend="listing_the_hubot_vocabulary"/>.</simpara>
<figure xml:id="listing_the_hubot_vocabulary">
<title>Listing the Hubot vocabulary</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/btwg_08in06.png"/>
</imageobject>
<textobject><phrase>btwg 08in06</phrase></textobject>
</mediaobject>
</figure>
<simpara>The <literal>pug me</literal> command is a favorite. Many people new to Hubot
quickly get sucked into spending hours looking at cute pictures of
pugs. Beware!</simpara>
</section>
</section>
</section>
<section xml:id="_installation_on_heroku">
<title>Installation on Heroku</title>
<simpara><indexterm>
<primary>Heroku</primary><secondary>Hubot installation on</secondary><tertiary>id=ix_chapter-06-hubot-activities-asciidoc4</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc4</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm><indexterm>
<primary>Hubot</primary><secondary>installation on Heroku</secondary><tertiary>id=ix_chapter-06-hubot-activities-asciidoc5</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc5</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm>Now that we&#8217;ve successfully started our Hubot locally, we can move it
to Heroku and keep it running even when our laptop is turned off.</simpara>
<section xml:id="_setting_up_heroku">
<title>Setting Up Heroku</title>
<simpara><indexterm>
<primary>Heroku</primary><secondary>setup</secondary>
</indexterm>
<indexterm>
<primary>setup</primary>
</indexterm>Heroku requires registration before using it. Heroku offers free plans and everything
we&#8217;ll do here can be done using one of them. Once you have created an
account, install the Heroku toolbelt found here:
<link xl:href="https://toolbelt.heroku.com/">https://toolbelt.heroku.com/</link>. The toolbelt provides a set
of tools useful for managing Heroku applications. You will need to
have Ruby set up as explained in <xref linkend="introduction"/>.</simpara>
<simpara>If your chatbot is working per the instructions given in the previous
section, then it is almost ready to deploy to Heroku. You&#8217;ll need to
add the same environment variable using the Heroku tools. In addition
to the authentication token for Slack, you will need to configure a
URL for your site. Heroku will generate a URL for you from the name of
your project (in this case <literal>inqry-chatbot</literal>); so as long as the name has
not been claimed already by someone else, you can name it as you will:</simpara>
<screen>$ heroku create inqry-chatbot
$ heroku config:add HEROKU_URL=https://inqry-chatbot.herokuapp.com/
$ heroku config:add HUBOT_SLACK_TOKEN=xxbo-3957767284-ZnxlH1n3ysLVgcD2dr1PZ9Cq
$ git push heroku master
Fetching repository, done.
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 317 bytes | 0 bytes/s, done.
Total 3 (delta 2), reused 0 (delta 0)

-----&gt; Node.js app detected
-----&gt; Requested node range:  0.10.x
...
-----&gt; Compressing... done, 6.8MB
-----&gt; Launching... done, v9
       https://inqry-chatbot.herokuapp.com/ deployed to Heroku

To git@heroku.com:inqry-chatbot.git
   d32e2db..3627218  master -&gt; master</screen>
<simpara>If you need to troubleshoot issues with your Hubot, you can always run
the heroku log command to view logs for your application, <literal>heroku logs -t</literal>:</simpara>
<screen>$ heroku logs -t
2014-11-18T07:07:18.716943+00:00 app[web.1]: Successfully 'connected'
as hubot
2014-11-18T07:07:18.576287+00:00 app[web.1]: Tue, 18 Nov 2014 07:07:18
GMT connect deprecated limit: Restrict request size at location of
read at
node_modules/hubot/.../express/.../connect/.../middleware/multipart.js:86:15
...</screen>
<simpara>When you send commands into your chat room you will notice events
inside of Heroku. This is a good way to verify that your bot is wired
into Slack properly.</simpara>
<simpara>You might also want to publish this repository into GitHub. Heroku,
as a part of hosting your live application, also hosts the full Git
repository of your Hubot (Hubot, as friendly as it tries to be, is
just another NodeJS application in the end). Heroku can host the
entirety of the source code for your Hubot for you, but does not have
the additional tools, like user management, that GitHub does. For this
reason, use your GitHub account as your code repository, the place where
team members develop new features of your chatbot. Build and test
locally, and then push into Heroku using the ease of the Git workflow
as a deployment layer.</simpara>
<simpara>Now that we have created and installed Hubot, let&#8217;s look at the
Activity API and determine how we want to code our extension.<indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc5</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc5</primary>
</indexterm><indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc4</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc4</primary>
</indexterm></simpara>
</section>
</section>
<section xml:id="_activity_api_overview">
<title>Activity API Overview</title>
<simpara><indexterm>
<primary>Activity API</primary><secondary>overview</secondary>
</indexterm>
<indexterm>
<primary>overview</primary>
</indexterm>The Activity API centers around <indexterm>
<primary>notifications</primary>
</indexterm>notifications: notifications are similar
to the notifications you see on social networking sites, events that
occur that document important points of interest inside a timeline of
activity. GitHub activity events are often tied to important
milestones inside of a developer&#8217;s day, activities like pushing
commits into the main remote repository, asking questions on
discussion threads associated with a repository, or assigning issues
to a developer for review.</simpara>
<simpara>These notifications are accessible to team members without
programmatically accessing the GitHub API. Team members are notified
of events inside of their workflow using email based on several
rules. GitHub will automatically send out notification emails when a
user has watched a repository and issues or comments are added, a pull
request is made, or there are comments made on a commit. In addition,
even if a user has not watched a repository, they will be notified if
that user is <emphasis>@mentioned</emphasis> (prefixing the @ character to a team
member&#8217;s name inside a comment), when an issue is assigned to them, or
when that user participates in a discussion associated with any
repository.</simpara>
<simpara>The GitHub policy for notification is definitely to err on the side of
being overly verbose. Many people live in their email, and making sure
that all important activities are distributed to the right people
involved makes sense. GitHub has a good set of rules for making
sure the correct notifications get to the right parties.</simpara>
<simpara>Email does falter as a to-do list, however, and at times the ease in
which email can be delivered breeds a secondary problem: overwhelm. It
can be very easy to lose focus (vital to building software) when you
are constantly context switching by checking email, and notifications
can often fly by. In addition, email is privately directed and
prevents easy collaboration; generally people don&#8217;t share email
inboxes. Let&#8217;s extend our Hubot to help us resolve these problems by taking
our GitHub notifications into a shared and "opt-in when you are logged-in"
communication channel.</simpara>
<section xml:id="_writing_a_hubot_extension">
<title>Writing a Hubot Extension</title>
<simpara><indexterm>
<primary>extensions</primary><secondary>Hubot</secondary>
</indexterm>
<indexterm>
<primary>Hubot</primary>
</indexterm><indexterm>
<primary>Hubot</primary><secondary>extensions</secondary>
</indexterm>
<indexterm>
<primary>extensions</primary>
</indexterm>Hubot extensions are written in either JavaScript or
<indexterm>
<primary>CoffeeScript</primary><secondary>characteristics</secondary>
</indexterm>
<indexterm>
<primary>characteristics</primary>
</indexterm>CoffeeScript. CoffeeScript is a intermediate language that compiles
directly to JavaScript. Many people prefer writing in CoffeeScript
because it has a cleaner syntax and writes "safer"
JavaScript (the syntax helps you avoid common tricky pitfalls in the
JavaScript language, like what "this" refers to).
CoffeeScript is an indentation-based language (much like
Python), and after the initial learning curve, can feel easier to read
than JavaScript, especially when you have many nested function
callbacks (common in JavaScript programming); it is easier to see
where a function begins and ends given the indentation levels. Hubot
is itself written in CoffeeScript, and we&#8217;ll write our extension in
CoffeeScript as well.</simpara>
<note>
<simpara><indexterm>
<primary>CoffeeScript</primary><secondary>indentation in</secondary>
</indexterm>
<indexterm>
<primary>indentation in</primary>
</indexterm><indexterm>
<primary>indentation, CoffeeScript</primary>
</indexterm>CoffeeScript is a language where indentation is important. For
readability purposes, when we display a snippet of code from a longer
file, there are times where we have changed the indentation of that
snippet and removed the initial indentation. If you were to copy the
code without realignment, the snippet would not work until you
reindented it to fit the context into which it sits.</simpara>
</note>
<simpara>The Hubot extension module format is exceedingly simple. You write
JavaScript modules (using the <literal>export</literal> syntax) and Hubot passes you in
a robot object you program using several API methods.</simpara>
<simpara><indexterm>
<primary>Hubot</primary><secondary>programming concepts</secondary>
</indexterm>
<indexterm>
<primary>programming concepts</primary>
</indexterm>There are a few concepts useful to programming Hubot. You can find
an example of each of these methods inside the <emphasis>example.coffee</emphasis> file
inside the <emphasis>scripts</emphasis> directory:</simpara>
<itemizedlist>
<listitem>
<simpara>Hubot has a "brain." This is an internal state object, which means
these values persist across chat messages. This state is not
persisted into a database by default, so this state is not restored
if you restart Hubot. However, a persistence mechanism is exposed
via Redis, though this is optional and requires configuration. The
brain is the way you set and get values that are saved across
discrete messages.</simpara>
</listitem>
<listitem>
<simpara>Hubot has different response mechanisms. They can choose to respond
only when they hear exact phrases or when keywords are found in any
message, and you don&#8217;t need to do the grunt work inside your code to
determine the differences between these communication types.</simpara>
</listitem>
<listitem>
<simpara>Hubot includes an HTTP server. You might need your Hubot to accept
requests from additional services beyond the chat service, and Hubot
makes it easy to accept these kinds of requests.</simpara>
</listitem>
<listitem>
<simpara>Hubot has a built-in HTTP client. You can easily access HTTP
resources within Hubot; many popular extensions to Hubot access a
web service when Hubot receives a request.</simpara>
</listitem>
<listitem>
<simpara>Hubot commands can include parameters. You can tell a Hubot to
do something multiple times and write a generic function that
accepts options.</simpara>
</listitem>
<listitem>
<simpara>Hubot can handle events. Each chat service has a generalized set of
events that are normalized to a common API. Hubot can be programmed
to interact with these events. For example, Hubot can perform
actions when a room topic changes or when users leave rooms.</simpara>
</listitem>
<listitem>
<simpara>Hubot can handle generic errors at the top level. Hubot can be
programmed with a catch-all error handler so that no matter where
your code failed, you can catch it without crashing your bot.</simpara>
</listitem>
</itemizedlist>
<simpara>Hubot will use the first five of these features:</simpara>
<itemizedlist>
<listitem>
<simpara>We will use the Hubot brain to store a PR review request. If Hubot
asks a user to review a PR, it needs to keep track of this so that
when the user responds it has some context of the request.</simpara>
</listitem>
<listitem>
<simpara>We will use the respond method to program our Hubot to handle a
request when a user accepts or declines the review request.</simpara>
</listitem>
<listitem>
<simpara>We will use the HTTP server to accept PR notifications from GitHub
webhooks.</simpara>
</listitem>
<listitem>
<simpara>We will use the HTTP client to get a list of users from Slack.</simpara>
</listitem>
<listitem>
<simpara>We will use the parameterization of requests to Hubot to retrieve
the specific pull request ID from a chat user message.</simpara>
</listitem>
</itemizedlist>
<simpara>There are examples of the other two features (events and generic
errors) inside the examples script that ship with the Hubot source
code but we won&#8217;t use those APIs in our Hubot.</simpara>
</section>
<section xml:id="_code_reviews_via_pull_requests">
<title>Code Reviews via Pull Requests</title>
<simpara><indexterm>
<primary>code reviews</primary><secondary>id=ix_chapter-06-hubot-activities-asciidoc6</secondary><tertiary>range=startofrange</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc6</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm><indexterm>
<primary>Hubot</primary><secondary>code reviews via pull requests</secondary><tertiary>id=ix_chapter-06-hubot-activities-asciidoc7</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc7</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm><indexterm>
<primary>pull requests</primary><secondary>code reviews via</secondary><tertiary>id=ix_chapter-06-hubot-activities-asciidoc8</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc8</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm>As we&#8217;ve seen in other chapters, pull requests are the mechanism used
on GitHub to easily integrate code changes into a project. Contributors
either fork the master repository and then issue a pull request against that
repository, or, if they have write permission to the main
repository, make a "feature" branch and then issue a pull request
against the "master" branch.</simpara>
<simpara>Pull requests often come with a chat message indicating several people
who should review the request. This tribal knowledge about who should
be involved is only in the head of the developer who created the
code. It could be that they invited the correct people. Or, it could
be that they invited the people they prefer to review their code
for various (and completely rational reasons). This can be an
effective way to engage the right people around a new piece of
code.</simpara>
<simpara>And inviting reviewers this way can have downsides as well: if the
person is otherwise engaged, pull requests can linger when a
notification email goes unread. And, there is good research to
indicate that the best performing teams are those who share all tasks
and responsibilities equally. It often does not scale to ask everyone
to participate in all code reviews associated with a pull
request. But it might be the case that randomly selecting developers
involved in a project is a better (and more efficient) way to review
code than asking the developer who created the code to determine these people.</simpara>
<simpara>Hubot will assign active chat room users to do code
reviews when a new pull request is created. <indexterm>
<primary>Activity API</primary><secondary>and pull requests</secondary>
</indexterm>
<indexterm>
<primary>and pull requests</primary>
</indexterm>We will use the GitHub
Activity API to subscribe to pull request events. When Hubot
becomes aware that a pull request needs review, it will randomly
assign a user in the chat room to do the review and then ask that user
if they want to accept the challenge. If they accept, we will note
that in the pull request comments.</simpara>
<section xml:id="_extension_boilerplate">
<title>Extension boilerplate</title>
<simpara><indexterm>
<primary>CoffeeScript</primary><secondary>extension boilerplate</secondary>
</indexterm>
<indexterm>
<primary>extension boilerplate</primary>
</indexterm><indexterm>
<primary>extensions</primary><secondary>boilerplate</secondary>
</indexterm>
<indexterm>
<primary>boilerplate</primary>
</indexterm>We will start writing our extension by defining the high-level
communication format we expect from our users. Our script has a simple
vocabulary: look for responses indicating acceptance or refusal of our
review requests. Our extension script should be in the
<emphasis>scripts</emphasis> directory and named <emphasis>pr-delegator.coffee</emphasis>. This is just the
back and forth we will be having with users; we are not yet writing
any code to handle the pull request notifications:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">module.exports = (robot) -&gt; <co xml:id="CO2-1"/>
       robot.respond /accept/i, (res) -&gt; <co xml:id="CO2-2"/>
               accept( res )
       robot.respond /decline/i, (res) -&gt; <co xml:id="CO2-3"/>
               decline( res )
       accept = ( res ) -&gt; <co xml:id="CO2-4"/>
               res.reply "Thanks, you got it!"
               console.log "Accepted!" <co xml:id="CO2-5"/>
       decline = ( res ) -&gt; <co xml:id="CO2-6"/>
               res.reply "OK, I'll find someone else"
               console.log "Declined!"</programlisting>
<simpara>This is a dense piece of code and can be confusing if you are new to
CoffeeScript. At the same time, hopefully you will agree that this is
amazingly powerful code for such a small snippet after reading these notes.</simpara>
<calloutlist>
<callout arearefs="CO2-1">
<para>All NodeJS modules start by defining entrypoints using the
<literal>exports</literal> syntax. This code defines a function that expects a single
parameter; when the function is executed, the parameter will be called a
robot. The Hubot framework will pass in a robot object for us that we
will program further down.</para>
</callout>
<callout arearefs="CO2-2">
<para>The Hubot API defines a method on the robot object called
<literal>respond</literal>, which we use here. It takes two parameters: a regular
expression to match against and a function that receives an instance of
the chat response object (called <literal>res</literal> here). The second line uses
the API for this response object to call a method <literal>accept</literal> with the
response object. We define accept in a moment.</para>
</callout>
<callout arearefs="CO2-3">
<para>We setup a response matcher for a decline response.</para>
</callout>
<callout arearefs="CO2-4">
<para>Now we define the <literal>accept</literal> method. The accept method receives the
response object generated by the Hubot framework and calls the <literal>reply</literal>
method, which, you guessed it, sends a message back into the chat
channel with the text "Thanks, you got it!"</para>
</callout>
<callout arearefs="CO2-5">
<para>The accept method then also calls <literal>console.log</literal> with information
that is displayed on the console from which we started Hubot. This is
a simple way for us to assure everything worked correctly; if we don&#8217;t
see this message, our code before this was broken. The <literal>console.log</literal>
is not visible to any users in the channel. It is good practice to
remove this code when you finalize your production code, but if you
forget, it won&#8217;t affect anything happening in the channel.</para>
</callout>
<callout arearefs="CO2-6">
<para>We then define the <literal>decline</literal> method using the same APIs as for the
<literal>accept</literal> method.</para>
</callout>
</calloutlist>
<simpara>If Hubot is running, you will need to restart it to reload any
scripts. Kill Hubot (using Ctrl-C), and then restart it, and then
play with commands inside your Slack site. Enter the commands
<literal>probot accept</literal> and <literal>probot decline</literal> and you&#8217;ll see Hubot
responding inside the channel. You&#8217;ll also see the message <literal>Accepted!</literal> or
<literal>Declined!</literal> printed to the console on which Hubot is
running.</simpara>
</section>
<section xml:id="_writing_tests_for_hubot_extensions">
<title>Writing tests for Hubot extensions</title>
<simpara><indexterm>
<primary>extensions</primary><secondary>writing tests for</secondary><tertiary>id=ix_chapter-06-hubot-activities-asciidoc9</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc9</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm><indexterm>
<primary>Hubot</primary><secondary>writing tests for extensions</secondary><tertiary>id=ix_chapter-06-hubot-activities-asciidoc10</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc10</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm>Now that we have the basics of our Hubot working, let&#8217;s make sure we
certify our code with some tests. <indexterm>
<primary>Jasmine</primary><secondary>testing framework</secondary>
</indexterm>
<indexterm>
<primary>testing framework</primary>
</indexterm>We&#8217;ll use the Jasmine testing
framework for NodeJS. It offers an elegant behavior-driven testing
syntax where you specify a behavior as the first parameter to an <literal>it</literal>
function, and as a second parameter, a function that is run as the
test itself. Jasmine manages running each <literal>it</literal> call and displays a
nice output of passing and failed tests at the end of your
run. Jasmine tests are typically written in JavaScript, but the latest versions of
<indexterm>
<primary>CoffeeScript</primary><secondary>Jasmine support tests</secondary>
</indexterm>
<indexterm>
<primary>Jasmine support tests</primary>
</indexterm>Jasmine support tests are also written in CoffeeScript. Hubot is written
in CoffeeScript, so let&#8217;s write our tests in CoffeeScript as
well. We need to put our tests inside a
directory called <emphasis>spec</emphasis> and make sure our filename ends with
<emphasis>.spec.coffee</emphasis>. Let&#8217;s use <emphasis>spec/pr-delegator.spec.coffee</emphasis> as the
complete filename. Jasmine expects spec files to have <emphasis>.spec.</emphasis> at the
end of their filename (before the extension, either <emphasis>.js</emphasis> or
<emphasis>.coffee</emphasis>); if your filename does not match this pattern Jasmine won&#8217;t
recognize it as a test.</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">Probot = require "../scripts/pr-delegator"
Handler = require "../lib/handler"

pr = undefined
robot = undefined

describe "#probot", -&gt;
        beforeEach () -&gt;
                robot = {
                        respond: jasmine.createSpy( 'respond' )
                        router: {
                                post: jasmine.createSpy( 'post' )
                                }
                        }

        it "should verify our calls to respond", (done) -&gt;
                pr = Probot robot
                expect( robot.respond.calls.count() ).toEqual( 2 )
                done()</programlisting>
<simpara>The first line in our test requires, or loads, the Hubot extension
module into our test script, giving us a function we save as a Probot
variable. We then create a<indexterm>
<primary>describe functions</primary>
</indexterm> <literal>describe</literal>
function, which is an organizing function to group tests. <literal>describe</literal>
functions take an indentifier (in this case <literal>#probot</literal>) and a function
that contains multiple <literal>it</literal> calls. In addition, a <literal>describe</literal> function
can also contain a <literal>beforeEach</literal> function that configures common
elements inside our <literal>it</literal> calls; in this case we create a faked robot
object we will pass into our <literal>Probot</literal> function call. When we are
running Hubot itself, Hubot creates the robot and passes it into the
<literal>Probot</literal> function, but when we run our tests, we generate a fake one
and query it to make sure it is receiving the proper
configuration. If we make a change inside our actual Hubot code and
forget to update our tests to verify those changes, our tests will
fail and we&#8217;ll know we need to either augment our tests, or something
broke inside our robot, a good automated sanity check for us when we
are feverishly coding away, animating our helpful Hubot.</simpara>
<simpara>You should see some similarities between the calls made to our robot
(<literal>robot.respond</literal> and <literal>robot.router.post</literal>) and the tests. We set up
"spies" using Jasmine that generate fake function calls capable of
recording any interaction from outside sources (either our production
code or the test code harness). Inside our <literal>it</literal> call, we
then verify that those calls were made. We use the <literal>expect</literal> function
to verify that we made two calls to the <literal>respond</literal> function
defined on the robot, and that <literal>robot.router.post</literal> has been called as
well.</simpara>
<simpara><indexterm>
<primary>Jasmine</primary><secondary>installation</secondary>
</indexterm>
<indexterm>
<primary>installation</primary>
</indexterm>We need to install Jasmine, and we do this by adding to our
<emphasis>package.json</emphasis> file. Append <literal>"jasmine-node": "^1.14.5"</literal> to the file,
and make sure to add a comma to the tuple above it. Adding this code
specifies that the minimum version of Jasmine node we will use is
"1.14.5".</simpara>
<programlisting language="json" linenumbering="unnumbered">...
  "hubot-shipit": "^0.1.1",
  "hubot-slack": "^3.2.1",
  "hubot-youtube": "^0.1.2",
  "jasmine-node": "^2.0.0"
},
"engines": {
...</programlisting>
<simpara>Runing the following commands will then install Jasmine (the library
and a test runner command-line tool) and run our tests. We abbreviate
some of the installation output to save space:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ npm install
...
hubot-slack@3.2.1 node_modules/hubot-slack
└── slack-client@1.2.2 (log@1.4.0, coffee-script@1.6.3, ws@0.4.31)
...
$ ./node_modules/.bin/jasmine-node --coffee spec/

.

Finished in 0.009 seconds
1 test, 1 assertions, 0 failures, 0 skipped</programlisting>
<simpara>Our tests pass and we now have a way to document and verify that our
code does what we think it does.<indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc10</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc10</primary>
</indexterm><indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc9</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc9</primary>
</indexterm></simpara>
</section>
<section xml:id="_setting_up_our_webhook">
<title>Setting up our webhook</title>
<simpara><indexterm>
<primary>Hubot</primary><secondary>webhook setup</secondary>
</indexterm>
<indexterm>
<primary>webhook setup</primary>
</indexterm><indexterm>
<primary>webhook</primary><secondary>for Hubot</secondary>
</indexterm>
<indexterm>
<primary>for Hubot</primary>
</indexterm>We are now in a position to start adding the actual functionality to
our Hubot. Our first requirement is to register for pull request
events. We could do this from within the GitHub website, but another
way is to use the cURL tool to create the webhook from the command
line. <indexterm>
<primary>authorization token</primary><secondary>for Hubot</secondary>
</indexterm>
<indexterm>
<primary>for Hubot</primary>
</indexterm>In order to do this, we need to first create an authorization
token, and then we can use that token to create a webhook.</simpara>
<simpara>To create the token, run this command, setting the proper variables
for your username instead of mine ("xrd"):</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ export USERNAME=xrd
$ curl https://api.github.com/authorizations --user $USERNAME --data
'{"scopes":["repo"], "note": "Probot access to PRs" }' -X POST</programlisting>
<simpara>This call can return in one of three ways. If your username or
password is incorrect, you will get an error response message like
this:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
  "message": "Bad credentials",
  "documentation_url": "https://developer.github.com/v3"
}</programlisting>
<simpara>If your username and password are correct and you don&#8217;t have
two-factor authentication turned on, the request will succeed and you
will get back a token inside the JSON response:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
  "id": 238749874,
  "url": "https://api.github.com/authorizations/9876533",
  "app": {
    "name": "Probot access to PRs",
    "url": "https://developer.github.com/v3/oauth_authorizations/",
    "client_id": "00000000000000000000"
  },
  "token": "fakedtoken1234",
  "hashed_token": "fakedhashedtoken7654",
  ...</programlisting>
<simpara>If you are using two-factor authentication then you will see a
response message like this:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
  "message": "Must specify two-factor authentication OTP code.",
  "documentation_url":
  "https://developer.github.com/v3/auth#working-with-two-factor-authentication"
}</programlisting>
<simpara>If you get this message in response to the prior cURL command, then
you will be receiving a one-time password via
your choice of a two-factor authentication alternative endpoint (either
SMS or a two-factor authentication app like Google Authenticator or
recovery codes that you printed out). If you
use text messaging, check your text messages and then resend the
request appending a header using cURL:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ curl https://api.github.com/authorizations --user $USERNAME --data
'{"scopes":["repo"], "note": "Probot access to PRs" }' -X POST
--header "X-GitHub-OTP: 423584"
Enter host password for user 'xrd':</programlisting>
<simpara>If all these steps complete successfully (regardless of whether you
are using two-factor authentication or not) you will then receive an OAuth token:<indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc8</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc8</primary>
</indexterm><indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc7</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc7</primary>
</indexterm><indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc6</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc6</primary>
</indexterm></simpara>
<programlisting language="json" linenumbering="unnumbered">{
  "id": 1234567,
  "url": "https://api.github.com/authorizations/1234567",
  "app": {
    "name": "Probot access to PRs (API)",
    "url": "https://developer.github.com/v3/oauth_authorizations/",
    "client_id": "00000000000000000000"
  },
  "token": "ad5a36c3b7322c4ae8bb9069d4f20fdf2e454266",
  "note": "Probot access to PRs",
  "note_url": null,
  "created_at": "2015-01-13T06:23:53Z",
  "updated_at": "2015-01-13T06:23:53Z",
  "scopes": [
    "notifications"
  ]
}</programlisting>
</section>
</section>
<section xml:id="_using_the_oauth_token_to_register_for_events">
<title>Using the OAuth Token to Register for Events</title>
<simpara><indexterm>
<primary>authorization token</primary><secondary>registering for events with</secondary><tertiary>id=ix_chapter-06-hubot-activities-asciidoc11</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc11</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm><indexterm>
<primary>Hubot</primary><secondary>using OAuth token to register for events</secondary><tertiary>id=ix_chapter-06-hubot-activities-asciidoc12</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc12</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm><indexterm>
<primary>OAuth</primary><secondary>tokens</secondary><tertiary>id=ix_chapter-06-hubot-activities-asciidoc13</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc13</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm><indexterm>
<primary>tokens, OAuth</primary><secondary>id=ix_chapter-06-hubot-activities-asciidoc14</secondary><tertiary>range=startofrange</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc14</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm>Once this is completed we now have our token we can use to
create a webhook. Make sure to use the correct repository name and
access token before running the cURL command. We will also need the
endpoint we created when we published into Heroku (in our case
<literal><link xl:href="https://inqry-chatbot.herokuapp.com">https://inqry-chatbot.herokuapp.com</link></literal>):</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ REPOSITORY=testing_repostory
$ TOKEN=ad5a36c3b7322c4ae8bb9069d4f20fdf2e454266
$ WEBHOOK_URL=https://inqry-chatbot.herokuapp.com/pr
$ CONFIG=$(echo '{
  "name": "web",
  "active": true,
  "events": [
    "push",
    "pull_request"
  ],
  "config": {
    "url": "'$WEBHOOK_URL'",
    "content_type": "form",
    "secret" : "XYZABC"
  }
}')
$ curl -H "Authorization: token $TOKEN" \
-H "Content-Type: application/json" -X POST \
-d "$CONFIG" https://api.github.com/repos/$USERNAME/$REPOSITORY/hooks
{
  "url": "https://api.github.com/repos/xrd/testing_repostory/hooks/3846063",
  "test_url":
  "https://api.github.com/repos/xrd/testing_repostory/hooks/3846063/test",
  "ping_url":
  "https://api.github.com/repos/xrd/testing_repostory/hooks/3846063/pings",
  "id": 3846063,
  "name": "web",
  "active": true,
  "events": [
    "push",
    "pull_request"
  ],
  "config": {
    "url": "https://inqry-chatbot.herokuapp.com/pr",
    "content_type": "json"
  },
  "last_response": {
    "code": null,
    "status": "unused",
    "message": null
  },
  "updated_at": "2015-01-14T06:23:59Z",
  "created_at": "2015-01-14T06:23:59Z"
}</programlisting>
<simpara>There is a bit of bash cleverness here, but nothing to be overly
disturbed by. We create a few variables we use in the final
command. Since the $CONFIG variable is particularly long, we use <literal>echo</literal>
to print out a bunch of information with the webhook URL in the
middle. If you want to see the result of that variable, type <literal>echo
$CONFIG</literal> and you&#8217;ll notice the snippet <literal>&#8230;&#8203; "url":
"https://inqry-chatbot.herokuapp.com/pr" &#8230;&#8203;</literal> properly interpolated.</simpara>
<simpara><indexterm>
<primary>Heroku</primary><secondary>API as webhood endpoint</secondary>
</indexterm>
<indexterm>
<primary>API as webhood endpoint</primary>
</indexterm>Here we use the Heroku API URL as our webhook endpoint. This means we
need to have things hosted on Heroku for the webhook to talk to our
HTTP server properly. We can do some things (like connecting the Hubot to
the Slack service) from behind a firewall and have it talk with other
chat room participants, but any webhook request will fail unless the
chat client is running on a publicly available server.</simpara>
<simpara>Be careful to make sure you use the <literal>content_type</literal> set to "form" (which
is the default, so you could leave it blank). Setting this to <literal>json</literal> will
make it difficult to retrieve the raw body inside your Hubot when the
post request is received and validate the request using a secure
digest. We want to make sure all requests are real requests from GitHub
and not a cracker attempting to maliciously inject themselves into our
conversations. To protect from this possible situation, we verify each
request back into GitHub by using the secret generated
when we created the webhook. We&#8217;ll discuss this in detail later in this
chapter, but for now, establish a secret when you create the hook. A
cracker might be able to guess about where our endpoint exists, but
unless Heroku or GitHub is compromised, they won&#8217;t know our webhook secret.</simpara>
<simpara>We should update our tests to make sure we anticipate this new
functionality. We will be using the Hubot HTTP server, which
piggybacks on the built-in express server running inside of Hubot. Our
new test should reflect that we use the <literal>router.post</literal> method exposed
to our Hubot, and that it is called once. We add this next test to the
end of our spec file:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">it "should verify our calls to router.post", (done) -&gt;
        pr = Probot robot
        expect( robot.router.post ).toHaveBeenCalled()
        done()</programlisting>
<simpara>This additional test will fail should we run it. Now we can add to our
Hubot and have it handle webhook callbacks from GitHub. Add this to
the end of the file:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">  robot.router.post '/pr', ( req, res ) -&gt;
        console.log "We received a pull request"</programlisting>
<simpara>Now if we run our tests, they all pass. If they do, publish our new
version of the app into Heroku. We&#8217;ll omit this step in the future,
but if you want to receive pull requests on the router you have set up,
remember that you need to publish your files into Heroku so the
endpoint is public.</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ./node_modules/.bin/jasmine-node --coffee spec/
..
$ git commit -m "Working tests and associated code" -a
...
$ heroku push

Finished in 0.009 seconds
2 tests, 2 assertions, 0 failures, 0 skipped
$ git push heroku master
Fetching repository, done.
Counting objects: 5, done.
Delta compression using up to 8 threads.
...</programlisting>
<simpara>We now have an end-to-end Hubot setup, ready to receive webhook
notifications.<indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc14</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc14</primary>
</indexterm><indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc13</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc13</primary>
</indexterm><indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc12</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc12</primary>
</indexterm><indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc11</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc11</primary>
</indexterm></simpara>
</section>
<section xml:id="_triggering_real_pull_requests">
<title>Triggering Real Pull Requests</title>
<simpara><indexterm>
<primary>Hubot</primary><secondary>triggering real pull requests</secondary><tertiary>id=ix_chapter-06-hubot-activities-asciidoc15</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc15</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm><indexterm>
<primary>pull requests</primary><secondary>testing Hubot with</secondary><tertiary>id=ix_chapter-06-hubot-activities-asciidoc16</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc16</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm>We can now start testing our Hubot with real GitHub
notifications. First, let&#8217;s set up a repository we can use for
testing. <indexterm>
<primary>hub tool</primary>
</indexterm>Creating the new repository on GitHub is a quick task if we
use the <literal>hub</literal> tool described in <xref linkend="Jekyll"/>:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ mkdir testing_repository
$ cd testing_repository
$ git init
$ touch test.txt
$ git add .
$ git commit -m "Initial checkin"
$ hub create
...</programlisting>
<simpara>Now we can create a real pull requests for our repository from the
command line and test our Hubot. A typical pull request flow looks
like the following:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a new branch</simpara>
</listitem>
<listitem>
<simpara>Add new content</simpara>
</listitem>
<listitem>
<simpara>Commit the content</simpara>
</listitem>
<listitem>
<simpara>Push the new branch into GitHub</simpara>
</listitem>
<listitem>
<simpara>Issue a pull request</simpara>
</listitem>
</orderedlist>
<simpara>All of this can be automated using a combination of Git commands and cURL.
We&#8217;ve seen some of these commands before and can reuse the previous
command-line invocations and variables we used when generating
our webhook using the API via cURL. Our config variable is similar,
but the required fields in this case are: the title and body for the
pull request, the "head" key that matches the name of the branch, and
where to merge it to using the "base" key.</simpara>
<simpara>Creating a new branch, adding some content, and then issuing a pull
request against the branch might be something we need to do several
(or more) times as we experiment and learn about the Hubot extension
API. The examples here work right out of the box, but don&#8217;t be fooled
into thinking that it all went exactly as we expected the first time.
Given that, these are commands you might want to perform multiple times as you are
experimenting, so let&#8217;s put the commands described in the previous paragraph
into a bash script that is generic and can be run multiple times. We
can call it issue-pull-request.sh and place the script inside the
test directory:</simpara>
<programlisting language="bash" linenumbering="unnumbered"># Modify these three variables
AUTH_TOKEN=b2ac1f43aeb8d73b69754d2fe337de7035ec9df7
USERNAME=xrd
REPOSITORY=test_repository

DATE=$(date "+%s")
NEW_BRANCH=$DATE
git checkout -b $NEW_BRANCH
echo "Adding some content" &gt;&gt; test-$DATE.txt
git commit -m "Adding test file to test branch at $DATE" -a
git push origin $NEW_BRANCH
CONFIG=$(echo '
{ "title": "PR on '$DATE'",
  "body" : "Pull this PR'$DATE'",
  "head": "'$NEW_BRANCH'",
  "base": "master"
}' )
URL=https://api.github.com/repos/$USERNAME/$REPOSITORY/pulls
curl -H "Authorization: token $AUTH_TOKEN" \
-H "Content-Type: application/json" -X POST -d "$CONFIG" "$URL"</programlisting>
<simpara>This script generates a unique string based on the current time. It
then creates and checks out a new branch based on that name, adds some
content to a unique file, commits it, pushes it into GitHub, and generates a
pull request using the API. All you will need to do is make a one-time
update to the three variables at the top of the script to match your
information. This script is resilient in that even if your auth token were incorrect (or
had expired) this command would do nothing other than add testing data
to your test repository, so you can experiment safely. Just be sure
to pay attention to whether you see a successful JSON request as shown
in the following code or an error message. And, as we are going to run this script as
a command, make it executable using the <literal>chmod</literal> command.</simpara>
<simpara>Now, let&#8217;s run it and see what happens:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ chmod +x ./issue-pull-request.sh
$ ./issue-pull-request.sh
{
  "url": "https://api.github.com/repos/xrd/testing_repostory/pulls/1",
  "id": 27330198,
  "html_url": "https://github.com/xrd/testing_repostory/pull/1",
  "diff_url": "https://github.com/xrd/testing_repostory/pull/1.diff",
  "patch_url": "https://github.com/xrd/testing_repostory/pull/1.patch",
  "issue_url": "https://api.github.com/repos/xrd/testing_repostory/issues/1",
  "number": 1,
  "state": "open",
  "locked": false,
  "title": "A PR test",
      "open_issues_count": 1,
...</programlisting>
<simpara>This returns a huge JSON response (abbreviated here), but you can see
the first item is a link to the pull request. For a human-readable
link, we should use the link called <literal>html_url</literal>. Were we to visit this
link, we could merge the pull request from within the GitHub web UI.</simpara>
<simpara>To see more context on what is happening with this pull request, once
we are looking at this pull request inside of GitHub, we can then navigate to the
settings for our repository, follow the link to "Webhooks and
Services" on the left navigation bar, and we will then find at the
very bottom of the page a list of recent deliveries to our webhook, as in <xref linkend="recent_failed_deliveries_from_our_webhook"/>.</simpara>
<figure xml:id="recent_failed_deliveries_from_our_webhook">
<title>Recent failed deliveries from our webhook</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/btwg_08in07.png"/>
</imageobject>
<textobject><phrase>btwg 08in07</phrase></textobject>
</mediaobject>
</figure>
<simpara>These requests all failed; our Hubot is not correctly configured
to handle real HTTP requests from GitHub. This does show that GitHub is
trying to do something when a pull request is received. We&#8217;ll work on
getting our handler code written and pushed into Heroku, and then
issue another PR.<indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc16</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc16</primary>
</indexterm><indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc15</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc15</primary>
</indexterm></simpara>
</section>
<section xml:id="_handling_pr_notifications_as_post_requests_over_http">
<title>Handling PR Notifications as Post Requests over HTTP</title>
<simpara><indexterm>
<primary>HTTP handler, handling PR notifications as post requests over</primary><secondary>id=ix_chapter-06-hubot-activities-asciidoc17</secondary><tertiary>range=startofrange</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc17</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm><indexterm>
<primary>Hubot</primary><secondary>handling PR notifications as post requests over HTTP</secondary><tertiary>id=ix_chapter-06-hubot-activities-asciidoc18</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc18</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm><indexterm>
<primary>post requests, handling PR notifications as</primary><secondary>id=ix_chapter-06-hubot-activities-asciidoc19</secondary><tertiary>range=startofrange</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc19</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm><indexterm>
<primary>pull requests</primary><secondary>handling notifications as post requests over HTTP</secondary><tertiary>id=ix_chapter-06-hubot-activities-asciidoc20</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc20</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm>Let&#8217;s build our HTTP handler when PR notifications arrive from
GitHub. At first glance, we might take the easy route, adding it
directly into the top-level script. But given the fact that
JavaScript handles events inside of callbacks and the fact that Hubot
extensions only export a single constructor (using the
<literal>module.exports</literal> syntax), it is easier to create, and more importantly
test, a separate module, which we require in our main extension script.</simpara>
<simpara>We start by writing our tests. We&#8217;ve already created a test that
verifies the call to <literal>robot.router.post</literal>. Our new functionality will
actually handle the PR notification, so let&#8217;s add a new grouping using
the describe syntax and call it "#pr". The new functionality is
simple: if the Hubot receives the proper parameters (most importantly
that the internal secret matches the secret sent on the request) then
we accept the PR as valid and message our room with further
instructions, namely inviting some user to review this pull
request. Our handler then needs to expose two methods:
<code><span class="keep-together">prHandler</span></code>, which is where we delegate any information coming from an
HTTP request to the <literal>/pr</literal> route, and a method where we can configure
the secret, which we call <code>set<span class="keep-together">Secret</span></code>. Once we have established this
internal signature for our handler library, we can add two simple
tests and then our library.</simpara>
<simpara>We have two tests: one that handles the correct flow and one that
handles the incorrect flow. In a before block (this happens before
each test) we set up a fake robot, and set the secret on our handler
module. Our faked robot implements the same methods a real Hubot
robot does (the messageRoom and send methods), but we create
Jasmine spies to verify these functions are called inside our
implementation code:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">describe "#pr", -&gt;
        secret = "ABCDEF"
        robot = undefined
        res = undefined

        beforeEach -&gt;
                robot = {
                        messageRoom: jasmine.createSpy()
                        }
                res = { send: jasmine.createSpy() }
                Handler.setSecret secret

        it "should disallow calls without the secret", (done) -&gt;
                req = {}
                Handler.prHandler( robot, req, res )
                expect( robot.messageRoom ).not.toHaveBeenCalled()
                expect( res.send ).toHaveBeenCalled()
                done()

        it "should allow calls with the secret", (done) -&gt;
                req = { body: { secret: secret } }
                Handler.prHandler( robot, req, res )
                expect( robot.messageRoom ).toHaveBeenCalled()
                expect( res.send ).toHaveBeenCalled()
                done()</programlisting>
<simpara>Now, add a file called <emphasis>./lib/handler.coffee</emphasis>:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">_SECRET = undefined

exports.prHandler = ( robot, req, res ) -&gt;
        secret = req.body?.secret
        if secret == _SECRET
                console.log "Secret verified, let's notify our channel"
                room = "general"
                robot.messageRoom room, "OMG, GitHub is on my caller-id!?!"
        res.send "OK\n"

exports.setSecret = (secret) -&gt;
        _SECRET = secret</programlisting>
<simpara>As you can see, the Hubot API does a lot of work for us: it processes
the JSON POST request to the <literal>/pr</literal> endpoint and provides us with the
parsed parameters inside the body object. We use that to retrieve the
secret from the request. Even if you have used CoffeeScript before,
you may not be familiar with the <literal>?.</literal> syntax: this just tests to see
if <literal>body</literal> is defined and if so, has a key named <literal>secret</literal>. This prevents
us from crashing if the secret is not sent in with the request. If the
secret from the request matches the configured secret, then we message
the room; otherwise we ignore the request. In either case, we need to
respond to the calling server by using the <literal>send</literal> method (<literal>send</literal> is
provided by the built-in <emphasis>express</emphasis> server Hubot uses to provide
an HTTP server). For debugging purposes we output that the secret
was validated, if it was in fact validated, but otherwise the behavior
of our response to the calling client is the same regardless of
whether they provided a correct secret or not. We don&#8217;t want to
provide an attacker with anything extra if they pass in an incorrect secret.</simpara>
<simpara>If we run our tests we will see them all pass&#x3a;</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ node_modules/jasmine-node/bin/jasmine-node \
--coffee spec/pr-delegator.spec.coffee
....

Finished in 0.01 seconds
4 tests, 6 assertions, 0 failures, 0 skipped</programlisting>
<simpara>Hubot will spawn the HTTP server wherever it runs so we can talk to it
on our local machine (though this will likely be inside a firewall and
inaccessible to GitHub), so we can test it using cURL
locally. Remember that our robot router accepts commands as HTTP POST
requests, so we need to specify a post request (using the <literal>--data</literal>
switch with cURL):</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ( HUBOT_SLACK_TOKEN=xoxb-3295776784-nZxl1H3nyLsVcgdD29r1PZCq \
./bin/hubot -a slack 2&gt; /dev/null | grep -i secret &amp; )
$ curl --data '' http://localhost:8080/pr
Invalid secret
OK
$ curl --data 'secret=XYZABC' http://localhost:8080/pr
Secret verified
OK
$ kill `ps a | grep node | grep -v grep | awk -F ' ' '{ print $1 }'`</programlisting>
<simpara>These commands verify that things are working properly. First, we
start the server, piping the output to <literal>grep</literal> to constrain output
related to our secret processing (we also background the
entire chain using an ampersand and parentheses, a bash trick). Then,
we hit the server running locally without the secret: the server (as
it is running in the same shell) prints out the
message "Invalid secret" using <literal>console.log</literal>, and then cURL prints out
"OK," which is what was returned from our server. If we run the command
again, this time including the secret as post parameters, we see that
Hubot verified the secret internally against its own secret, and then
cURL again prints "OK," which was what the express server inside of
Hubot returned to the calling client. The final line quits Hubot:
this command finds the PID for the Hubot client (which runs as a node
process) and then sends it a SIGHUP signal, signaling to Hubot that it
should quit.</simpara>
<simpara>Provided you connected correctly to your Slack site, you&#8217;ll also see a
message inside your #general channel, which says "OMG, GitHub is on my
caller-id!?!" We now have a simple way to trigger a pull request notification
without going through the formality of actually generating a pull
request. Between our script, which issues real pull requests through the
GitHub API, and this one that fakes a webhook notification, we have the
ability to test our code externally as we develop it. Of course, our
tests are valuable, but sometimes it is impossible to understand
what is happening inside of our Hubot without running against the
real Hubot and not a test harness.</simpara>
<section xml:id="_assigning_an_active_chat_room_user">
<title>Assigning an active chat room user</title>
<simpara><indexterm>
<primary>pull requests</primary><secondary>assigning an active chat room user to</secondary><tertiary>id=ix_chapter-06-hubot-activities-asciidoc21</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc21</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm>Now that we have an incoming pull request (albeit one we are
faking), we need to write the code to find a random user and assign them
to the pull request.</simpara>
<warning>
<simpara>This next section is redundant; our Hubot will function
exactly as we need it to if you were to disregard any code from this
section. <indexterm>
<primary>Slack API</primary><secondary>id=ix_chapter-06-hubot-activities-asciidoc22</secondary><tertiary>range=startofrange</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc22</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm>As I was writing this book, I mistakenly missed the fact that
the Hubot <literal>brain</literal> contains a list of users and found another avenue to
get that data, the Slack API. I wrote the chapter using the Slack
API, and then discovered my mistake.</simpara>
<simpara>Initially I planned to remove
this entire section. However, it does demonstrate the ease of using an
external service through the built-in HTTP client, which is a powerful
feature of Hubot. And it also demonstrates how powerful tests aid you
when developing a Hubot extension; I was able to refactor to use a
radically different internal code path for getting the list of users
and maintain faith that the end-to-end process of my code works by
refactoring and then fixing broken tests. And, though not important
for this section per se, the Slack API provides much richer data on
the users logged in to a room, which could be valuable in other
situations. If you want to skip to the next section, you will have all
the code to build our Hubot as we described earlier. But I think it
is a worthwhile read for general Hubot understanding.</simpara>
</warning>
<simpara>To find a user in the room, one option is to go
outside the Hubot API and use the Slack API to query for a list of
users. The Slack API provides an endpoint, giving you all
users currently in a room. To access the Slack API, we will
use the built-in Hubot HTTP client. Once we have the
list of members in the room we can look over this list
and randomly choose a member and deliver the PR request to them:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">_SECRET = undefined

anyoneButProbot = (members) -&gt;  <co xml:id="CO3-1"/>
        user = undefined
        while not user
                user = members[ parseInt( Math.random() * \
		     members.length ) ].name
                user = undefined if "probot" == user
        user

sendPrRequest = ( robot, body, room, url ) -&gt; <co xml:id="CO3-2"/>
        parsed = JSON.parse( body )
        user = anyoneButProbot( parsed.members )
        robot.messageRoom room, "#{user}: Hey, want a PR? #{url}"

exports.prHandler = ( robot, req, res ) -&gt;
        slack_users_url =   <co xml:id="CO3-3"/>
                "https://slack.com/api/users.list?token=" +
                process.env.HUBOT_SLACK_TOKEN
        secret = req.body?.secret <co xml:id="CO3-4"/>
        url = req.body?.url

        if secret == _SECRET and url
                room = "general"
                robot.http( slack_users_url ) <co xml:id="CO3-5"/>
                        .get() (err, response, body) -&gt;
                                sendPrRequest( robot, body, \
					       room, url ) unless err
        else
                console.log "Invalid secret or no URL specified"
        res.send "OK\n"

exports.setSecret = (secret) -&gt;
        _SECRET = secret</programlisting>
<calloutlist>
<callout arearefs="CO3-1">
<para>We define a method called <literal>anyoneButProbot</literal> that takes a list of
users and finds a random one, as long as it is not the Hubot.</para>
</callout>
<callout arearefs="CO3-2">
<para>The <literal>sendPrRequest</literal> method parses the JSON returned from the Slack
API and then sends the members inside of the object into the
<literal>anyoneButProbot</literal> call. It then uses the Hubot API to send a message
to the room asking if that user will accept the pull request review
invitation.</para>
</callout>
<callout arearefs="CO3-3">
<para>We build the URL to the Slack service by tacking on the Slack API
token to the base Slack API URL.</para>
</callout>
<callout arearefs="CO3-4">
<para>As we did before, we pull out the secret and the PR URL, and then
make sure they both exist.</para>
</callout>
<callout arearefs="CO3-5">
<para>We use the built-in HTTP client to make a GET request to the
Slack API. Unless we receive an error in the response callback, we
use the data provided by the Slack API to initiate the PR review
request.</para>
</callout>
</calloutlist>
<simpara>To test this using our cURL command, we need to modify the invocation
slightly:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ curl --data 'secret=XYZABC&amp;url=http://pr/1' \
http://localhost:8080/pr</programlisting>
<simpara>Our randomly selected user will see the text <literal>username: Hey, want a
PR? <link xl:href="http://pr/1">http://pr/1</link></literal> (and the Slack client will format that link as a
clickable URL).</simpara>
<simpara>Unfortunately, our tests are now broken: we now have the failure <literal>TypeError:
Object #&lt;Object&gt; has no method 'http'</literal>. Our mocked robot object that
we pass into our tests does not have the HTTP interface that comes
with Hubot, so we should add it to our custom Robot. The method
signature for the HTTP client (which comes from the
<literal>node-scoped-http-client</literal> NodeJS package) is hairy: you chain calls
together to build up an HTTP client request and end up with a function
returned into which you pass a callback where you handle the response
body. This module makes you write code that is not particularly
testable (said another way, it was challenging for me to understand
what the faked test implementation should look like), but the setup
code does work and the test itself documents an interface to our robot,
which is easily understandable. We simulate the
same chain, defining an <literal>http</literal> attribute on the mocked robot object, an
attribute that resolves to a function call itself. Calling that function
returns an object that has a <literal>get</literal> method, and calling that function
returns a function callback that when called executes that function
with three parameters. In real life that function callback would
contain the error code, the response object, and the JSON. In our
case, as long as the error code is empty, our implementation will
parse the JSON for members, and then issue the PR request:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">json = '{ "members" : [ { "name" : "bar" } , { "name" : "foo" } ] }'

httpSpy = jasmine.createSpy( 'http' ).and.returnValue(
        { get: () -&gt; ( func ) -&gt;
                func( undefined, undefined, json ) } )

beforeEach -&gt;
        robot = {
                messageRoom: jasmine.createSpy( 'messageRoom' )
                http: httpSpy
                }

        res = { send: jasmine.createSpy( 'send' ) }
        Handler.setSecret secret

it "should disallow calls without the secret", (done) -&gt;
        req = {}
        Handler.prHandler( robot, req, res )
        expect( robot.messageRoom ).not.toHaveBeenCalled()
        expect( httpSpy ).not.toHaveBeenCalled()
        expect( res.send ).toHaveBeenCalled()
        done()

it "should disallow calls without the url", (done) -&gt;
        req = { body: { secret: secret } }
        Handler.prHandler( robot, req, res )
        expect( robot.messageRoom ).not.toHaveBeenCalled()
        expect( httpSpy ).not.toHaveBeenCalled()
        expect( res.send ).toHaveBeenCalled()
        done()

it "should allow calls with the secret", (done) -&gt;
        req = { body: { secret: secret, url: "http://pr/1" } }
        Handler.prHandler( robot, req, res )
        expect( robot.messageRoom ).toHaveBeenCalled()
        expect( httpSpy ).toHaveBeenCalled()
        expect( res.send ).toHaveBeenCalled()
        done()</programlisting>
<simpara>The code we write here was definitely not a piece of code where
testing came easy; I refactored this multiple times to find a balance
between an easy-to-read test and easy-to-read code. Writing test code
takes effort, but when both your tests and code are readable and
minimal, you generally can be sure you have a good implementation.</simpara>
<simpara>We now have a functional and complete implementation of the code to
retrieve a list of users and assign an incoming pull request out to a
randomly selected user from that list<indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc22</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc22</primary>
</indexterm>.<indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc21</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc21</primary>
</indexterm></simpara>
</section>
<section xml:id="_the_user_list_from_the_hubot_brain">
<title>The user list from the Hubot brain</title>
<simpara><indexterm>
<primary>Hubot brain</primary><secondary>user list from</secondary>
</indexterm>
<indexterm>
<primary>user list from</primary>
</indexterm><indexterm>
<primary>pull requests</primary><secondary>and user list from Hubot brain</secondary>
</indexterm>
<indexterm>
<primary>and user list from Hubot brain</primary>
</indexterm>Instead of using the Slack API, we can replace the code with a
much simpler call to <literal>robot.brain.users</literal>. Calling into the Slack users
API takes a callback, but the <literal>brain.users</literal> call does not, which
simplifies our code. We do verify inside our tests that we make a call to
the HTTP Jasmine spy on the <literal>get</literal> function, so we will want to remove
that inside our tests. We will need to provide a new function called
<literal>users</literal> to the Hubot inside the faked brain we created.</simpara>
<simpara>Unfortunately, things don&#8217;t just work when we change our code to this:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">...
users = robot.brain.users()
sendPrRequest( robot, users, room, url, number )
...</programlisting>
<simpara>It is likely that what we got back from the Slack API and what Hubot
stores inside its brain for users are functionally the same
information, but structurally stored very differently. How can we
investigate whether this assumption is correct?
NodeJS has a standard library module called <literal>util</literal>, which includes
useful utility functions, as you might expect from the name.
One of them is <literal>inspect</literal>, which will dig into an object and
create a pretty printed view. If we use this module and <literal>console.log</literal>
we can see the full contents of a live response object passed into our
<literal>accept</literal> function. A line like <literal>console.log( require(
'util' ).inspect( users ) )</literal> displays the following:</simpara>
<programlisting language="json" linenumbering="unnumbered">{ U04FVFE97:
   { id: 'U04FVFE97',
     name: 'ben',
     real_name: 'Ben Straub',
     email_address: 'xxx' },
  U038PNUP2:
   { id: 'U038PNUP2',
     name: 'probot',
     real_name: '',
     email_address: undefined },
  U04624M1A:
   { id: 'U04624M1A',
     name: 'teddyhyde',
     real_name: 'Teddy Hyde',
     email_address: 'xxx' },
  U030YMBJY:
   { id: 'U030YMBJY',
     name: 'xrd',
     real_name: 'Chris Dawson',
     email_address: 'xxx' },
  USLACKBOT:
   { id: 'USLACKBOT',
     name: 'slackbot',
     real_name: 'Slack Bot',
     email_address: null } }</programlisting>
<simpara>Ah, we were right: the Slack API returns an array while this is an
associative array (called a hash in other languages). So, we need to
refactor our inputs to the test to take an associative array instead
of an array, and then we need a function to flatten it
out (after that our code will work the same as before). We will return
that when the user calls <literal>robot.brain.users</literal> so add a new spy as the
<literal>users</literal> key inside our fake robot:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">...
users = { CDAWSON: { name: "Chris Dawson" }, BSTRAUB: { name: "Ben Straub" } }
brainSpy = {
        users: jasmine.createSpy( 'getUsers' ).and.returnValue( users ),
        set: jasmine.createSpy( 'setBrain' ),
...</programlisting>
<simpara>Inside our implementation code, flatten out the user associative array
and find the user inside the new flattened array:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">...
flattenUsers = (users) -&gt;
        rv = []
        for x in Object.keys( users )
               rv.push users[x]
        rv

anyoneButProbot = ( users ) -&gt;
        user = undefined
        flattened = flattenUsers( users )
        while not user
                user = flattened[ parseInt( Math.random() * \
		     flattened.length ) ].name
                user = undefined if "probot" == user
        user

...</programlisting>
</section>
<section xml:id="_sending_pr_data_via_webhook">
<title>Sending PR data via webhook</title>
<simpara><indexterm>
<primary>Hubot</primary><secondary>sending PR data via webhook</secondary><tertiary>id=ix_chapter-06-hubot-activities-asciidoc23</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc23</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm><indexterm>
<primary>pull requests</primary><secondary>sending data via webhook</secondary><tertiary>id=ix_chapter-06-hubot-activities-asciidoc24</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc24</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm><indexterm>
<primary>webhook</primary><secondary>sending PR data via</secondary><tertiary>id=ix_chapter-06-hubot-activities-asciidoc25</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc25</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm>Our wiring is almost complete, so let&#8217;s actually send real pull
request information. If we run our script <literal>issue-pull-request.sh</literal> we
will see it sending data out to our Hubot. Once we have deployed to
Heroku, our Hubot is listening on a public hostname. GitHub will
accept the pull request and then send a JSON inside the body of a POST
request made to our Hubot. This JSON looks very different from the
URL-encoded parameters we provide in our cURL script, so we need to
modify our code to fit.</simpara>
<simpara>If we retrieve the JSON from a POST, it will look something like this
(reformatted for clarity and brevity):</simpara>
<programlisting language="json" linenumbering="unnumbered">{
    "action":"opened",
    "number":13,
    "pull_request": {
      "locked" : false,
      "comments_url" :
      "https://api.github.com/repos/xrd/test_repository/issues/13/comments",
      "url" : "https://api.github.com/repos/xrd/test_repository/pulls/13",
      "html_url" : "https://github.com/xrd/test_repository/pulls/13",
      }
      ...
}</programlisting>
<simpara>Most importantly, you see a URL (the <literal>html_url</literal> more specifically) we will use inside our Hubot
message to the user. Retrieving the JSON and parsing it is trivial
inside our Hubot:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">...
exports.prHandler = ( robot, req, res ) -&gt;
        body = req.body
        pr = JSON.parse body if body
        url = pr.pull_request.html_url if pr
        secret = pr.secret if pr

        if secret == _SECRET and url
                room = "general"
...</programlisting>
<simpara>Here you see we pull out the body contents, process them as JSON,
extract the secret and the URL from the parsed JSON, and then go
through our normal routine.</simpara>
<simpara>Our tests are simple, and require that we send in JSON:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">...
it "should disallow calls without the secret and url", (done) -&gt;
        req = {}
        Handler.prHandler( robot, req, res )
        expect( robot.messageRoom ).not.toHaveBeenCalled()
        expect( httpSpy ).not.toHaveBeenCalled()
        expect( res.send ).toHaveBeenCalled()
       done()

it "should allow calls with the secret and url", (done) -&gt;
        req = { body: '{ "pull_request" : { "html_url" : "http://pr/1" },
        "secret": "ABCDEF" }' }
        Handler.prHandler( robot, req, res )
        expect( robot.messageRoom ).toHaveBeenCalled()
        expect( httpSpy ).toHaveBeenCalled()
        expect( res.send ).toHaveBeenCalled()
        done()
...</programlisting>
<simpara>We are putting the secret inside the JSON as a convenience. The secret
will not come in with the JSON when GitHub sends us JSON via the
webhook, but this is an easy way to provide it to our handler for the
moment. If we run our tests, they should pass now.<indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc25</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc25</primary>
</indexterm><indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc24</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc24</primary>
</indexterm><indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc23</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc23</primary>
</indexterm></simpara>
</section>
<section xml:id="_securing_the_webhook">
<title>Securing the webhook</title>
<simpara><indexterm>
<primary>Hubot</primary><secondary>securing webhook</secondary><tertiary>id=ix_chapter-06-hubot-activities-asciidoc26</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc26</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm><indexterm>
<primary>pull requests</primary><secondary>securing webhook</secondary><tertiary>id=ix_chapter-06-hubot-activities-asciidoc27</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc27</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm><indexterm>
<primary>webhook</primary><secondary>securing</secondary><tertiary>id=ix_chapter-06-hubot-activities-asciidoc28</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc28</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm>Our Hubot is now in a position where it will operate correctly if the
secret passes validation and the webhook data is passed properly. Now
we need to secure the webhook. GitHub signs your data inside the
webhook payload, which provides you with a way to verify the data
really came from an authorized host. We need to decode it inside our
handler. To do this, we will need to retrieve the secure hash GitHub
provides inside the request headers. Then, we will need to calculate
the hash ourselves using the secret we maintain internally. If these
hashes match, then we know the incoming request and JSON is truly from
GitHub and not an attacker:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">...
getSecureHash = (body, secret) -&gt;
        hash = crypto.
                createHmac( 'sha1', secret ).
                update( "sha1=" + body ).
                digest('hex')
        console.log "Hash: #{hash}"
        hash

exports.prHandler = ( robot, req, res ) -&gt;
        slack_users_url =
                "https://slack.com/api/users.list?token=" +
                process.env.HUBOT_SLACK_TOKEN
        body = req.body
        pr = JSON.parse body if body
        url = pr.pull_request.html_url if pr
        secureHash = getSecureHash( body, _SECRET ) if body
        webhookProvidedHash = req.headers['HTTP_X_HUB_SIGNATURE' ] \
			    if req?.headers
        secureCompare = require 'secure-compare'

        if secureCompare( secureHash, webhookProvidedHash ) and url
                room = "general"
                robot.http( slack_users_url ) -&gt;
                        .get() (err, response, body) -&gt;
                                sendPrRequest( robot, body, \
					       room, url ) unless err
        else
...</programlisting>
<simpara>The signature is<indexterm>
<primary>hash message authentication code (HMAC)</primary>
</indexterm> a <emphasis>hash message authentication code</emphasis> (HMAC). HMAC
cryptography is vulnerable to timing attacks. When you use this
encryption technique, the time it takes to complete a comparison of
the computed hash and the sent hash can be the starting point for an attacker to gain
forced access to a server. More specifically to JavaScript, naive
comparison operators like <literal>==</literal> will leak this timing information.
<indexterm>
<primary>secure&#8211;compare module</primary>
</indexterm>To eliminate the risk that this information could be used to
compromise the host system, we use a module called <literal>secure-compare</literal>
that obscures this timing information when making a comparison. To
load this module, we need to add it to our <emphasis>package.json</emphasis> manifest file
with the command <literal>npm install secure-compare --save</literal>.</simpara>
<simpara>Now we can adjust our tests to fit the new reality of our handler:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">...
it "should disallow calls without the secret and url", (done) -&gt;
        req = {}
        Handler.prHandler( robot, req, res )
        expect( robot.messageRoom ).not.toHaveBeenCalled()
        expect( httpSpy ).not.toHaveBeenCalled()
        expect( res.send ).toHaveBeenCalled()
        done()

it "should allow calls with the secret and url", (done) -&gt;
        req = { body: '{ "pull_request" : { "html_url" : "http://pr/1" }}',
      headers: { "HTTP_X_HUB_SIGNATURE" :
               "cd970490d83c01b678fa9af55f3c7854b5d22918" } }
        Handler.prHandler( robot, req, res )
        expect( robot.messageRoom ).toHaveBeenCalled()
        expect( httpSpy ).toHaveBeenCalled()
        expect( res.send ).toHaveBeenCalled()
        done()
...</programlisting>
<simpara>You&#8217;ll notice we moved the secret out of the JSON and into the
headers. This is the same structure our Hubot will see when the
GitHub webhook encodes the content of the JSON and provides us with a
secure hash in the HTTP_X_HUB_SIGNATURE key. Inside our test we will need
to provide the same signature inside our mocked request object. We
could duplicate our secure hash generation code from the
handler implementation, or we could be lazy and just run our tests
once (knowing they will fail this time), watch for the
console.log output that says "Hash: cd970490d83c&#8230;&#8203;" and copy this
hash into our mocked request object. Once we do this, our tests will
pass.</simpara>
<simpara>Now, after reloading our Hubot, if we issue a pull request using our
issue-pull-request.sh script, we should see the matching
hashes. But we won&#8217;t (at least if you used the same <emphasis>package.json</emphasis>
file as we specified earlier) because of a critical bug inside of Hubot
at the time of this writing.</simpara>
<simpara><indexterm>
<primary>Express.js</primary>
</indexterm><indexterm>
<primary>NodeJS</primary><secondary>and Express.js</secondary>
</indexterm>
<indexterm>
<primary>and Express.js</primary>
</indexterm>As we mentioned earlier, Hubot bundles Express.js, a high-performance
web framework for NodeJS. Express.js has a modular architecture, where
middleware is inserted into a request and response chain. This
approach to building functionality and the wide array of middleware
allows web developers to string together various standardized
middleware components to use only those features needed for the
problem at hand. Common middleware includes static file handlers (for
serving static files), cookie handlers, session handlers, and body
parsers. You can imagine circumstances where you would not need all of
these (or you might need others) and this flexibility makes
Express.js a popular choice for building NodeJS web applications.</simpara>
<simpara>The body <indexterm>
<primary>body parser middleware</primary>
</indexterm>parser middleware is of particular interest to us here: the
body parser middleware is used to convert the "body" of a request into
a JavaScript object attached to the request object. Previously you saw us
access it inside a variable we called <literal>req</literal> inside our callback;
obviously this stands for request. The body parser takes on converting
whatever data content comes from inside the body of the HTTP request into a
structured JavaScript associative array inside the <literal>body</literal> object within our
request object. If the body is URL encoded (as the PR information is
encoded if we create the webhook with the <literal>content_type</literal> set to
<literal>form</literal>), then the body parser URL decodes the content, parses it as
JSON, and then sets the inflated object to the body attribute on our
request object. Normally, this is a very handy process that removes a
lot of grunt work for web application authors.</simpara>
<simpara>Unfortunately, because the <literal>express</literal> object is bundled and configured for us long
before our extension is loaded, we cannot interrupt the load order of
the body parser middleware inside our extension, which means we
cannot get access to the raw body content. The body parser middleware
processes the stream of
data by registering for events inside the HTTP request flow. NodeJS
made a mark on web application development by providing a network
application toolkit centered around one of the
most controversial features of JavaScript: the asynchronous
callback. In NodeJS, processes register for events and then return
control to the host program. In other languages, like Ruby, for
example, when building services that receive data from clients, by
default, you listen for incoming data, and the moment you tell your
program to listen, you have blocked other processing. Asynchronous
programming is by no means a new concept (threading in many languages,
for example), but NodeJS offers a simple way to interact with
asynchronous functions through event registration. In the case of
express middleware, however, this event registration process bites us,
because middleware loaded first gets first access to incoming data,
and once the body parser has processed our body content, we can no longer access the original content. We need access to the raw body
content, and there is no way to install our own middleware that would
provide it inside our Hubot extension when a PR request is received
on the router.</simpara>
<simpara>What options do we have then? Well, fortunately, every bit of our
stack here is open source, and we can modify the code inside Hubot
that sets up our express server to fit our needs. This code is
installed by the <literal>npm</literal> tool in the <em>node_modules</em> directory, and we
can easily find where express is configured inside of Hubot. There are
issues with doing it this way: if we rerun <literal>npm install</literal> we will blow
away our <em>node_modules</em> directory, and this is something Heroku will
do if it is not told otherwise. A better way might be to fork Hubot
and store our own copy of Hubot inside of GitHub and then specify our
forked copy inside of the <emphasis>package.json</emphasis>? file. This has issues too; if
Hubot gets updated with a critical security flaw, we need to merge
those changes into our fork, a maintenance issue we would avoid
if we use tagged releases from the main repository. There is,
unfortunately, no perfect way to resolve this problem that does not
itself create other problems.</simpara>
<simpara>If you do choose to modify the built-in Hubot code, modify the file
<emphasis>robot.coffee</emphasis> inside the <em>node_modules/hubot/src/</em> directory. The
<em>node_modules</em> directory, in case memory fails, is where the NodeJS
package manager (npm) builds out the local dependency tree for
libraries, and this is the file Hubot uses internally to build the
robot object and set up the express HTTP server. If we add the
following code at line 288 (this line number might vary if you are not
using the same version of Hubot we specify in our <emphasis>package.json</emphasis>), we
can install a custom middleware callback that will provide us with
the raw body we can use when verifying the HMAC signature:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">...
app.use (req, res, next) =&gt;
  res.setHeader "X-Powered-By", "hubot/#{@name}"
  next()

app.use (req, res, next) =&gt;
  req.rawBody = ''
  req.on 'data', (chunk) -&gt;
    req.rawBody += chunk
  next()

app.use express.basicAuth user, pass if user and pass
app.use express.query()

...</programlisting>
<simpara>Express <indexterm>
<primary>express middleware</primary>
</indexterm>middleware have a very simple interface: they are nothing more
than a JavaScript function callback that receives a request, response,
and continuation function passed as parameters. We
register a listener when data content (the body) is propagated, and
then add the body content to a variable on the request object. When
the request object is passed in to our handler for pull requests within
our Hubot, we have the raw data prefilled. The <literal>next()</literal> function is
used to indicate to the middleware host that the next middleware can
proceed.</simpara>
<simpara>We now need to adjust our tests to fit this new requirement. We prime
the pump with a request object that has this <literal>rawBody</literal> inside
it, and we should properly encode the content using
<literal>encodeURIComponent</literal> to match the format in which it will be appearing
from GitHub:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">...
it "should allow calls with the secret and url", (done) -&gt;
        payload =  '{ "pull_request" : { "html_url" : "http://pr/1" } }'
        bodyPayload = "payload=#{encodeURIComponent(payload)}"
        req = { rawBody: bodyPayload,
        headers: { "x-hub-signature" : \
		 "sha1=dc827de09c5b57da3ee54dcfc8c5d09a3d3e6109" } }

        Handler.prHandler( robot, req, res )
        expect( robot.messageRoom ).toHaveBeenCalled()
        expect( httpSpy ).toHaveBeenCalled()
        expect( res.send ).toHaveBeenCalled()
        done()
...</programlisting>
<simpara>Our implementation breaks our tests, so we will need to modify the
cost to use the <literal>rawBody</literal> attribute on the request object, break it
apart from the payload key/value pair, URI decode it, and then if all
that works, parse the JSON and start the verification process. Our
tests describe all this for us. The new <literal>prHandler</literal> method looks like
this:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">...
exports.prHandler = ( robot, req, res ) -&gt;

        rawBody = req.rawBody
        body = rawBody.split( '=' ) if rawBody
        payloadData = body[1] if body and body.length == 2
        if payloadData
                decodedJson = decodeURIComponent payloadData
                pr = JSON.parse decodedJson

                if pr and pr.pull_request
                        url = pr.pull_request.html_url
                        secureHash = getSecureHash( rawBody )
                        signatureKey = "x-hub-signature"
                        if req?.headers
                                webhookProvidedHash =
                                        req.headers[ signatureKey ]
                        secureCompare = require 'secure-compare'
                        if url and secureCompare( "sha1=#{secureHash}",
                                        webhookProvidedHash )
                                room = "general"
                                users = robot.brain.users()
                                sendPrRequest( robot, users, room, url )
                        else
                                console.log "Invalid secret or no URL specified"
                else
                        console.log "No pull request in here"

        res.send "OK\n"

_GITHUB = undefined

...</programlisting>
<simpara>When all is said and done, is verifying the signature even worth it?
If we are not hosting our Hubot on a service that handles our router
requests over HTTPS, this HMAC verification could be compromised. And,
given the issues with maintaining our own copy of the Hubot code in
order to permit the validation inside our Hubot extension, it might be
best to ignore the validation header. The worst case, as our extension
is written now, would be that an attacker could fake a pull request
notification, and falsely engage chat room users around it. If the PR
the attacker used was fake, it might confuse our Hubot, but no real
harm would be done. If they used an existing real PR, an attacker
could trick our Hubot into adding data to the PR, adding confusion in
the comments about who accepted the review request. We won&#8217;t solve that
potential problem with this code, but you can imagine adding code to
our Hubot that handles a case like this (for example, by checking
first to see if someone was already tagged on the PR, and ignoring
successive incoming webhooks associated with that PR).<indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc28</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc28</primary>
</indexterm><indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc27</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc27</primary>
</indexterm><indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc26</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc26</primary>
</indexterm></simpara>
</section>
<section xml:id="_responding_to_the_pr_request">
<title>Responding to the PR request</title>
<simpara><indexterm>
<primary>Hubot</primary><secondary>responding to pull requests</secondary><tertiary>id=ix_chapter-06-hubot-activities-asciidoc29</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc29</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm><indexterm>
<primary>pull requests</primary><secondary>responding to</secondary><tertiary>id=ix_chapter-06-hubot-activities-asciidoc30</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-06-hubot-activities-asciidoc30</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm>Our Hubot is now programmed to generate a pull request review message and
send it to a random user. What happens when they respond? They can
respond in two ways obviously: accepting the request or declining the
request. We put placeholders in our Hubot extension to notify us with
a debugging message when the user responds and send a message back to
whoever sent us a message, but now we can actually wire up handling
the response and adding to the pull request on GitHub based on the
user we are interacting with (provided they accepted).</simpara>
<simpara>There are multiple ways in which a Hubot can interact with chat room messages. <indexterm>
<primary>hear method</primary>
</indexterm><indexterm>
<primary>respond method</primary>
</indexterm>We chose the <literal>respond</literal> method, but there is another method called <literal>hear</literal> we could have used. <literal>respond</literal> is used when the message is preceded by the Hubot name, so only messages that look like <literal>probot: accept</literal> or <literal>@probot decline</literal> or <literal>/ accept</literal> (if the Hubot name alias is enabled) will be processed by our Hubot. We could have used <literal>hear</literal> but in our case we are processing a simple response, and without a clear direction for the message, it would be difficult to always make sure we were interpreting the message in the correct context. <literal>respond</literal> makes more sense here.</simpara>
<simpara>If they decline the request, let&#8217;s just graciously note that the offer was declined:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">...
exports.decline = ( res ) -&gt;
        res.reply "No problem, we'll go through this PR in a bug scrub"

...</programlisting>
<simpara>We are asking someone to accept a pull request, and there is a possible
situation where two could come in within a very short period of
time. For this reason, it probably makes sense for us to indicate the
pull request identifier in the communication with the target
user. And, users should be told to reply with a string like <literal>accept
112</literal>. The Hubot can then interpret this to mean they are accepting PR
#112 and not the other pull request the Hubot invited John to
respond to 10 seconds later.</simpara>
<simpara>If we do this, our Hubot does need to save the state of pull request
invitations. <indexterm>
<primary>Hubot brain</primary><secondary>and pull request state</secondary>
</indexterm>
<indexterm>
<primary>and pull request state</primary>
</indexterm>Fortunately, there is an extremely easy way to do this
using the "brain" of our Hubot. The brain is a persistent store,
typically backed by Redis, into which you can keep any type of
information. You simply reference the <literal>robot.brain</literal> and use methods
like <literal>get</literal> or <literal>set</literal> to retrieve and store information. The <literal>set</literal>
method takes any key and any value but note that the Hubot brain does
not do much with your value if that value happens to be a complex
object; if you want to properly serialize something beyond a flat
value, you should probably call <literal>JSON.stringify</literal> on the object to
maintain full control over the roundtrip storing and retrieval.</simpara>
<simpara>Let&#8217;s modify our Hubot handler to deal with accepting or declining
responses (and change our extension file to deal with this new
interface). Of course, we will need to add to our tests. Finally, we
will need to set up a way to provide the GitHub API key to our Hubot
handler, so we&#8217;ll add a method to do that that looks almost exactly
like the one for setting our secret key.</simpara>
<simpara><indexterm>
<primary>node&#8211;github module</primary>
</indexterm>We&#8217;ll use a GitHub API NodeJs module called <literal>node-github</literal>, found on
GitHub at <link xl:href="https://github.com/mikedeboer/node-github">https://github.com/mikedeboer/node-github</link>. If we look
at the API documentation, we see that it supports authentication using
an OAuth token (using the <code>github.<span class="keep-together">authenticate</span>( {  'type' : 'oauth': 'token' : '...' }</code> syntax), and has methods we can use to add a comment to an
issue or pull request associated with a repository (using the
<literal>github.issues.createComment</literal> method).</simpara>
<simpara>Knowing that this module handles most of the work for us between these
two methods, we can start by writing our tests. We&#8217;ll create a new
describe block called <literal>#response</literal> that groups our tests together. As
we noted earlier, our Hubot can take affirmative and negative
responses, so our tests should reflect these two code paths. Our setup
block (the <literal>beforeEach</literal> section) in both cases should do the same
thing for each response&#x2014;make the pull request invitation to a random user: this all
happens inside our <literal>prHandler</literal> code. We don&#8217;t need to verify the
expectations of this method since that got that covered by prior
tests. After we get our handler to the right state, we need to test
that the handler works correctly with an <literal>accept</literal> and <literal>decline</literal> method
(they don&#8217;t yet exist in our handler code so we&#8217;ll add them
next).</simpara>
<simpara>Our accept request handler triggers our Hubot to
contact GitHub and add a comment to the pull request noting
our targeted chat user accepted the request. The network
connection to the GitHub API uses the GitHub API bindings from within
the <literal>node-github</literal> module. We want to make this testable, so we should pass in the
GitHub binding object inside our interface, and during the test, pass
in a mocked object. If we review the documentation for the
<literal>createComment</literal> in the GitHub API binding, we see it requires
information about the repository such as the user or organization
that owns the repository, the repository name, the issue number (pull
requests are also referenced by issue numbers), and the comment
itself. To get this information we simply need to decode it from the
Hubot handler that receives the pull request information, and we
will add code that does this (and is exposed in our handler for
testing). We saw that a pull request comes in through a large JSON
response, and we can use the URL we used earlier as the way we decode
this information. So, we&#8217;ll need to have two more tests inside our
<literal>#response</literal> block, one for the decoding of the URL into a message
object, and another to retrieve the username we insert into the
comment stored in the pull request on the repository. We know what our
test URL looks like since we saw it in our PR webhook message, but we
don&#8217;t yet have the structure of the chat message from which we can
pull out our username, so our test will need to be adjusted when we
know what it really looks like.</simpara>
<simpara>Declining the request means nothing happens. If we
mock out our GitHub API binding, acceptance should log in (using the
<literal>authenticate</literal> method) and then call <literal>createComment</literal>. These are
directly pulled from the GitHub API NodeJS documentation. Finally, we
should record the result of this operation inside the chat room, which
happens using the reply method on our response object:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">...
describe "#response", -&gt;
        createComment = jasmine.createSpy( 'createComment' ).and.
                callFake( ( msg, cb ) -&gt; cb( false, "some data" ) )
        issues = { createComment: createComment }
        authenticate = jasmine.createSpy( 'ghAuthenticate' )
        responder = { reply: jasmine.createSpy( 'reply' ),
        send: jasmine.createSpy( 'send' ) }
        beforeEach -&gt;
                githubBinding = { authenticate: authenticate, \
					      	  issues: issues }
                github = Handler.setApiToken( githubBinding, \
				       	 		      "ABCDEF" )
                req = { body: '{ "pull_request" : \
                         { url : "http://pr/1" } }', \
                         headers: { "HTTP_X_HUB_SIGNATURE" : \
                         "cd970490d83c01b678fa9af55f3c7854b5d22918" } }
                Handler.prHandler( robot, req, responder )

        it "should tag the PR on GitHub if the user accepts", (done) -&gt;
                Handler.accept( responder )
                expect( authenticate ).toHaveBeenCalled()
                expect( createComment ).toHaveBeenCalled()
                expect( responder.reply ).toHaveBeenCalled()
                done()

        it "should not tag the PR on GitHub if the user declines", \
	   	   (done) -&gt;
                Handler.decline( responder )
                expect( authenticate ).toHaveBeenCalled()
                expect( createComment ).not.toHaveBeenCalledWith()
                expect( responder.reply ).toHaveBeenCalled()
                done()

        it "should decode the URL into a proper message object " + \
	   	   "for the createMessage call", (done) -&gt;
                url = "https://github.com/xrd/testing_repository/pull/1"
                msg = Handler.decodePullRequest( url )
                expect( msg.user ).toEqual( "xrd" )
                expect( msg.repository ).toEqual( "testing_repository" )
                expect( msg.number ).toEqual( "1" )
                done()

        it "should get the username from the response object", (done) -&gt;
                res = { username: { name: "Chris Dawson" } }
                expect( Handler.getUsernameFromResponse( res ) ).toEqual \
							 "Chris Dawson"
                done()</programlisting>
<simpara>Note that this code was indented to save space, but yours will be
nested in several deeper levels of indentation.
Refer to the sample repository for the exact code if there is confusion.</simpara>
<simpara>Our tests will fail if we run them now. So, let&#8217;s write the code at
the end of our delegator extension. We need code that parses the URL into the
appropriate structured message object, code to put the reminder into
the pull request comment on GitHub, and code that pulls the user out
of the response object passed to us. The first two of these are within
reach; basic JavaScript and reading the GitHub API
binding documentation will get us to these two. The third one requires a
little more investigation, so we will leave this as a placeholder for now.</simpara>
<simpara>To convert the URL into the object necessary for the <literal>createMessage</literal>
call, we just need to split the message into pieces by the slash
character, and then retrieve the correct items by index. We probably
could add some additional tests that cover passing in empty strings,
or other edge cases, but we&#8217;ll leave it as an exercise to the
reader. Our code does not crash in these cases, but it would be
nice to have coverage of our expectations represented in our tests:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">...
_GITHUB = undefined
_PR_URL = undefined

exports.decodePullRequest = (url) -&gt;
        rv = {}
        if url
                chunks = url.split "/"
                if chunks.length == 7
                        rv.user = chunks[3]
                        rv.repository = chunks[4]
                        rv.number = chunks[6]
        rv

exports.getUsernameFromResponse = ( res ) -&gt;
        "username"

exports.accept = ( res ) -&gt;

        msg = exports.decodePullRequest( _PR_URL )
        username = exports.getUsernameFromResponse( res )
        msg.body = "@#{username} will review this (via Probot)."

        _GITHUB.issues.createComment msg, ( err, data ) -&gt;
                unless err
                        res.reply "Thanks, I've noted that in a PR comment!"
                else
                        res.reply "Something went wrong, " + \
				  "I could not tag you on the PR comment."

exports.decline = ( res ) -&gt;
        res.reply "OK, I'll find someone else."
        console.log "Declined!"

exports.setApiToken = (github, token) -&gt;
        _API_TOKEN = token
        _GITHUB = github
        _GITHUB.authenticate type: "oauth", token: token

exports.setSecret = (secret) -&gt;
        _SECRET = secret</programlisting>
<simpara>To summarize, we added an internal variable called <literal>_GITHUB</literal> where we will store a
reference to our instantiation of the GitHub API binding. Our
interface to the <code>setApi<span class="keep-together">Token</span></code> call passes in the instantiation; this
method takes our OAuth token and the binding because using an
interface like this means we can pass in a mocked binding inside our
tests. When we are not running inside a test, this method call
authenticates against the GitHub API, readying the API binding to make
connections to the GitHub API itself.</simpara>
<simpara>Our top-level extension script looks like this now:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">handler = require '../lib/handler'

handler.setSecret "XYZABC"
github = require 'node-github'
handler.setApiToken github, "12345ABCDEF"

module.exports = (robot) -&gt;
        robot.respond /accept/i, ( res ) -&gt;
                handler.accept( res )

        robot.respond /decline/i, ( res ) -&gt;
                handler.decline( res )

        robot.router.post '/pr', ( req, res ) -&gt;
                handler.prHandler( robot, req, res )</programlisting>
<simpara>If you were to look only at this code, the interface is clean, and the
bulk of the work is handled by our very testable handler.<indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc30</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc30</primary>
</indexterm><indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc29</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc29</primary>
</indexterm></simpara>
</section>
<section xml:id="_peering_into_the_response_object">
<title>Peering into the response object</title>
<simpara><indexterm>
<primary>callback</primary>
</indexterm><indexterm>
<primary>Hubot</primary><secondary>and pull request response object</secondary>
</indexterm>
<indexterm>
<primary>and pull request response object</primary>
</indexterm><indexterm>
<primary>pull requests</primary><secondary>and response object</secondary>
</indexterm>
<indexterm>
<primary>and response object</primary>
</indexterm><indexterm>
<primary>respond callback</primary>
</indexterm>We need to get the username, and it stands to reason that the object passed
to us when we get a respond callback might have it in there. The
<literal>respond</literal> method provided by the Hubot API is documented mostly by
way of the example scripts that come with Hubot. There is very little
information on what the parameter passed to your callback looks
like. Let&#8217;s use the <literal>util</literal> library to inspect the data and print it to
the console. We abbreviate the full output here, and show you that it
contains information on the  user who sent the message to our
Hubot. We can access this information by using
<literal>response.message.user.name</literal> if, for example, we wanted to retrieve
the name of the user:</simpara>
<programlisting language="json" linenumbering="unnumbered">{ robot:
   { name: 'probot',
     brain:
      { data: [Object],
  ...
  message:
   { user:
      { id: '...',
        name: 'xrd',
        real_name: 'Chris Dawson',
        email: 'chrisdawson@example.com'
     ...
     text: 'probot accept',
     rawText: 'accept',
     rawMessage:
      { _client: [Object],
  ...
  match: [ 'probot accept', index: 0, input: 'probot accept' ],
  ...
}</programlisting>
<simpara>Inside it all we can find information we need,
specifically the username and email. So, let&#8217;s update our test and
our handler code. The last test in our spec file can be modified to
look like this:</simpara>
<programlisting role="pagebreak-before" language="coffeescript" linenumbering="unnumbered">...
it "should get the username from the response object", (done) -&gt;
        res = { message: { user: { name: "Chris Dawson" } } }
        expect( Handler.getUsernameFromResponse( res ) ).toEqual "Chris Dawson"
        done()

...</programlisting>
<simpara>And, our handler code defining <literal>getUsernameFromResponse</literal> simply turns into this:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">...
exports.getUsernameFromResponse = ( res ) -&gt;
        res.message.user.name

...</programlisting>
<simpara>With this information in hand, we can properly comment on the pull
request. Well, almost.</simpara>
</section>
<section xml:id="_unifying_usernames_via_the_collaborators_api">
<title>Unifying usernames via the Collaborators API</title>
<simpara><indexterm>
<primary>Collaborators API, unifying usernames via</primary>
</indexterm><indexterm>
<primary>Hubot</primary><secondary>unifying usernames via Collaborators API</secondary>
</indexterm>
<indexterm>
<primary>unifying usernames via Collaborators API</primary>
</indexterm><indexterm>
<primary>pull requests</primary><secondary>unifying usernames via Collaborators API</secondary>
</indexterm>
<indexterm>
<primary>unifying usernames via Collaborators API</primary>
</indexterm><indexterm>
<primary>usernames, unifying via Collaborators API</primary>
</indexterm>If the Slack username for the person who accepted the pull request is an
exact match with their GitHub username, then we can assume they are
the same person in real life and create a comment inside the pull
request reminding them (and anyone else) that they will be reviewing
the PR. We can use the collaborator subsection of the Repository API
to look up their name on GitHub.</simpara>
<simpara>If we don&#8217;t find them inside the list of users and there is not an
exact match with their Slack name then we have at least one problem,
maybe two. First, we could just have a mismatch in their identities
(their usernames are different on each site). If this is the case, we
could ask them to clarify this inside the Slack room. We do have
another case: the user is not a collaborator on the repository hosted
on GitHub. If
this is the case, clarifying their username is not going to help. The
Repository API does support adding a user to the list of collaborators
so we could do that here, but this arguably is a moment where a larger
discussion should happen (write access to a repository is a big
resposibility in a way that being inside a chat room is not). Adding a
user as a repository collaborator should not be automated inside a chat
room. Because of the complexity here, we will write code to unify a
username inside the chat room, but we won&#8217;t handle the case where
there is no clarification to be made because they are not in the
repository collaborator list.</simpara>
<simpara>Using the GitHub API binding we passed into our <literal>setApiToken</literal>
call we will verify the user exists as a collaborator on the
repository. The API binding provides a method called <literal>getCollaborator</literal>
inside the <literal>repos</literal> namespace we can use to verify that a
username is on the list of collaborators. It takes as the first
parameter a  message that is used to specify the repository and
owner, and then an attribute called <literal>collabuser</literal>, which is the name you
want to ensure is a collaborator. The second parameter to the function
is a callback that is executed once the request has completed. If the
callback returns without an error code, then our Hubot should tag the
pull request with a comment confirming and message the room.</simpara>
<simpara>Our new test reflects usage of the <literal>repos.getCollaborator</literal> call. In
our test setup block we mock out the call to <literal>getCollaborator</literal>
and use Jasmine to "spy on" it so we can assure it was called later
in our actual test. Our setup is more beefy than before, but we are
following the same patterns of generating spies to watch methods, and
implementing our fake callbacks when necessary. We can also move our
message inside the response object into the one created in our setup
block so that we can use it inside all of our subtests, rather than
creating a new object for each test inside the test body:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">...
send: jasmine.createSpy( 'send' ),
message: { user: { name: "Chris Dawson" } } }
getCollaborator = jasmine.createSpy( 'getCollaborator' ).and.
        callFake( ( msg, cb ) -&gt; cb( false, true ) )
repos = { getCollaborator: getCollaborator }

...

it "should tag the PR on GitHub if the user accepts", (done) -&gt;
        Handler.accept( robot, responder )
        expect( authenticate ).toHaveBeenCalled()
        expect( createComment ).toHaveBeenCalled()
        expect( responder.reply ).toHaveBeenCalled()
        expect( repos.getCollaborator ).toHaveBeenCalled()
        done()</programlisting>
<simpara>Our handler can then implement the accept and decline methods in full:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">...
exports.accept = ( robot, res ) -&gt;

        prNumber = res.match[1]
        url = robot.brain.get( prNumber )

        msg = exports.decodePullRequest( url )
        username = exports.getUsernameFromResponse( res )
        msg.collabuser = username

        _GITHUB.repos.getCollaborator msg, ( err, collaborator ) -&gt;
                msg.body = "@#{username} will review this (via Probot)."

                _GITHUB.issues.createComment msg, ( err, data ) -&gt;
                        unless err
                                res.reply "Thanks, I've noted that " + \
					  "in a PR comment. " + \
				          "Review the PR here: #{url}"
                        else
                                res.reply "Something went wrong."  + \
				          "I could not tag you " + \
					  "on the PR comment: " +
            "#{require('util').inspect( err )}"

exports.decline = ( res ) -&gt;
        res.reply "No problem, we'll go through this PR in a bug scrub"
...</programlisting>
<simpara>We now have a full implementation of both the <literal>accept</literal> and <literal>decline</literal>
methods inside our Hubot.</simpara>
</section>
<section xml:id="_sanitizing_our_source_code">
<title>Sanitizing our source code</title>
<simpara><indexterm>
<primary>Hubot</primary><secondary>sanitizing source code</secondary>
</indexterm>
<indexterm>
<primary>sanitizing source code</primary>
</indexterm>It is typically bad form to save passwords (or other access
credentials, like OAuth tokens or secrets) inside of source
code. Right now we have hardcoded them into our application inside of
the <emphasis>pr-delegator.coffee</emphasis> file. We could instead retrieve them from
the environment of the running process:</simpara>
<programlisting language="coffeescript" linenumbering="unnumbered">...
handler.setSecret process.env.PROBOT_SECRET
github = require 'github'
ginst = new github version: '3.0.0'
handler.setApiToken ginst, process.env.PROBOT_API_TOKEN
...</programlisting>
<simpara><indexterm>
<primary>command line</primary><secondary>launching Hubot from</secondary>
</indexterm>
<indexterm>
<primary>launching Hubot from</primary>
</indexterm>When we launch our Hubot from the command line, we will need to use a
command like this as we are testing locally from our laptop:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ PROBOT_SECRET=XYZABC \
PROBOT_API_TOKEN=926a701550d4dfae93250dbdc068cce887531 \
HUBOT_SLACK_TOKEN=xoxb-3295776784-nZxl1H3nyLsVcgdD29r1PZCq \
./bin/hubot -a slack</programlisting>
<simpara><indexterm>
<primary>Heroku</primary><secondary>publishing into</secondary>
</indexterm>
<indexterm>
<primary>publishing into</primary>
</indexterm>When we publish into Heroku, we will want to set these as environment
variables using the appropriate Heroku commands:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ heroku config:set PROBOT_API_TOKEN=926a701550d4dfae93250dbdc068cce887531
Adding config vars and restarting myapp... done, v12
PROBOT_API_TOKEN=926a701550d4dfae93250dbdc068cce887531

$ heroku config:set PROBOT_SECRET=XYZABC
Adding config vars and restarting myapp... done, v12
PROBOT_SECRET=XYZABC</programlisting>
<simpara>Don&#8217;t forget that when we run our tests, we will need to specify the
environment variables on the command line as well:<indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc20</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc20</primary>
</indexterm><indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc19</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc19</primary>
</indexterm><indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc18</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc18</primary>
</indexterm><indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc17</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc17</primary>
</indexterm></simpara>
<programlisting language="bash" linenumbering="unnumbered">$ PROBOT_SECRET=XYZABC \
PROBOT_API_TOKEN=926a701550d4dfae93250dbdc068cce887531 \
node_modules/jasmine-node/bin/jasmine-node --coffee \
spec/pr-delegator.spec.coffee</programlisting>
</section>
</section>
</section>
<section xml:id="_summary">
<title>Summary</title>
<simpara>Our Hubot is alive! We went through building a robot that can
interact with us inside a chat room, then refactored the robot so that its
functionality is contained into a highly testable module. Along
the way, we got intimate with the Hubot API, and even discussed how to
modify (and the drawbacks surrounding) modifying the source code to
Hubot itself. Finally, we demonstrated how to use the Activity API
receiving (and faking data) coming from a GitHub webhook.<indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-06-hubot-activities-asciidoc0</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-06-hubot-activities-asciidoc0</primary>
</indexterm></simpara>
<simpara>In the next chapter we will look at building a single-page application
that edits information inside a GitHub repository using JavaScript and
the GitHub.js library talking to the Pull Request API.</simpara>
</section>
</section>
</article>