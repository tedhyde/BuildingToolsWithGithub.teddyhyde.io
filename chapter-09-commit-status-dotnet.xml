<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>.NET and the Commit Status API</title>
<date>2018-11-09</date>
</info>
<section xml:id="commit_status">
<title>.NET and the Commit Status API</title>
<simpara><indexterm>
<primary>Commit Status API</primary><secondary>id=ix_chapter-09-commit-status-dotnet-asciidoc0</secondary><tertiary>range=startofrange</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-09-commit-status-dotnet-asciidoc0</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm>At the risk of oversimplifying things too much, one way to look at a Git repository is as just a long series of commits.
Each commit contains quite a bit of information: the contents of the source files, who created the commit and when, the author&#8217;s comments on what changes the commit introduces, and so on.
This is all good stuff, and works very well for Git&#8217;s main use case: controlling the history of a software project.</simpara>
<simpara>GitHub&#8217;s Commit Status API adds another layer of metadata to a commit: what various services <emphasis>say</emphasis> about that commit.
This capability primarily shows itself in the pull request UI, as shown in <xref linkend="status_pr"/>.
Each commit in the pull request is annotated with a symbol indicating its status&#x2014;a red "&#xd7;" for failure or error, a green "&#x2713;" for success, or an amber "&#x2022;" to indicate that a decision is in the process of being made.
This feature also surfaces at the bottom of the pull request; if the last commit in the branch is not marked as successful, you get a warning about merging the request.</simpara>
<figure xml:id="status_pr">
<title>Commit status in the pull request UI</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/btwg_0501.png"/>
</imageobject>
<textobject><phrase>btwg 0501</phrase></textobject>
</mediaobject>
</figure>
<simpara><indexterm>
<primary>continuous&#8211;integration service</primary>
</indexterm>The most obvious application for this feature is a continuous-integration service.
A program like Jenkins will get a notification when new commits are pushed to a branch, run a build/test cycle using the new code, and post the results through the Commit Status API.
An application like this can even include a link back to the build results, so the user can find out which tests failed.
This is a great way to bring together everything needed to make a decision about a proposal: what code has changed, what do people think about it, and does this change break anything?
The answer to all of these questions is available on the same page: the pull-request conversation view.</simpara>
<simpara>But building and testing is only the beginning; the status of a commit can be used for other purposes as well.
For example, open source projects often have a license agreement you must sign in order to submit a contribution.
These are called "contributor license agreements," and usually contain language about licensing the contribution to the maintainers of the project.
But it&#8217;s tedious to manually check every incoming pull request to see if the author has signed the CLA, so a continuous-integration-style service can be used for this.
CLAHub is one such example: it checks to see if all of the authors of the contained commits have signed the CLA, and marks the latest commit as "error" if not.</simpara>
<simpara>So now that we know what the feature is, and what its intended use is, let&#8217;s take a look at how a program can interact with it.</simpara>
<section xml:id="_the_api">
<title>The API</title>
<simpara><indexterm>
<primary>Commit Status API</primary><secondary>statuses in</secondary><tertiary>id=ix_chapter-09-commit-status-dotnet-asciidoc1</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-09-commit-status-dotnet-asciidoc1</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm>First, let&#8217;s talk about <indexterm>
<primary>access control</primary>
</indexterm>access control.
<indexterm>
<primary>OAuth</primary><secondary>and Commit Status API</secondary>
</indexterm>
<indexterm>
<primary>and Commit Status API</primary>
</indexterm>The Commit Status API exposes the need for OAuth as few others do.
Making a repository private means you want complete control of what people or applications can access it.
Naturally you trust GitHub&#8217;s internal code to do the right thing with your data, but what about some random application from the Internet?
OAuth gives you a way to grant private-repository access to an application <emphasis>with limits</emphasis>&#x2014;the use of OAuth scopes allows an application to ask for a specific set of permissions, but it won&#8217;t be able to do just any old thing with your data.
Plus, this way you&#8217;re always in control of these permissions; you can revoke an application&#8217;s access at any time.</simpara>
<simpara>The OAuth system includes the concept of <indexterm>
<primary>scopes</primary>
</indexterm>scopes, which can be requested by and granted to an application, each of which allows a certain set of actions.
The Commit Status API requires the <literal>repo:status</literal> OAuth scope, which allows an application read and write access to <emphasis>just</emphasis> commit statuses; there is no access granted to the actual contents of the repository.
This might seem strange: how can you judge the status of a commit without being able to inspect its contents?
Just remember that this feature has use cases beyond continuous integration, and an application may not need full access to make a decision.
For services that do need to be able to look at the repository contents, you can request <indexterm>
<primary>repo scope</primary>
</indexterm>the <literal>repo</literal> scope, which grants read <emphasis>and</emphasis> write access to the entire contents of a repository, including commit statuses.
As of this writing, there&#8217;s no way to request read-only access to repositories, so if a service needs access to your data, you have to trust it with write access.</simpara>
<simpara>You can also use this API in anonymous mode, without using OAuth at all.
However, in that case you&#8217;re limited to reading statuses from public repositories; there is no writing, and private repositories are off-limits.</simpara>
<simpara>Just to summarize:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">OAuth scope</entry>
<entry align="left" valign="top">Access to statuses</entry>
<entry align="left" valign="top">Access to repo data</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>None (anonymous)</simpara></entry>
<entry align="left" valign="top"><simpara>Read-only on public repos</simpara></entry>
<entry align="left" valign="top"><simpara>Read-only on public repos</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>repo:status</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read/write</simpara></entry>
<entry align="left" valign="top"><simpara>None</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>repo</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read/write</simpara></entry>
<entry align="left" valign="top"><simpara>Read/write</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<section xml:id="_raw_statuses">
<title>Raw Statuses</title>
<simpara><indexterm>
<primary>Commit Status API</primary><secondary>raw status</secondary>
</indexterm>
<indexterm>
<primary>raw status</primary>
</indexterm>Now that we know how we get access to commit statuses, let&#8217;s see what they look like.
Commit statuses exist as atomic entities, and each commit can have a practically unlimited number of them (the actual number is in the thousands).
You can query for existing statuses by doing a GET request to the API server at <code>/repos/<em>&#x3c;user&#x3e;</em>/<em>&#x3c;repo&#x3e;</em>/<em>&#x3c;ref&#x3e;</em>/statuses</code>, and it will return a list of them that looks like this:</simpara>
<programlisting language="json" linenumbering="unnumbered">[
  {
    "url": "https://api.github.com/repos/…",
    "id": 224503786,
    "state": "success",
    "description": "The Travis CI build passed",
    "target_url": "https://travis-ci.org/libgit2/libgit2/builds/63428108",
    "context": "continuous-integration/travis-ci/push",
    "created_at": "2015-05-21T03:11:02Z",
    "updated_at": "2015-05-21T03:11:02Z"
  },
  …
]</programlisting>
<simpara>Most of this is self-explanatory, but a couple of fields need explaining:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Field</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>state</literal></simpara></entry>
<entry align="left" valign="top"><simpara>One of <literal>success</literal>, <literal>failure</literal>, <literal>error</literal>, or <literal>pending</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>target_url</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A URL for the specific decision made for this commit (in this case a build/test log), which helps the user figure out why a particular decision was reached.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>context</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Used for correlating multiple status updates to a single service; each application sets this according to its own rules, but any process that creates statuses should post the <literal>pending</literal> status and the result status using the same context value.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>This API is useful for getting the raw data involved, but it gets complicated quickly.
How do you decide if a given commit is "good?"
What if there are three pending statuses, one success, another pending, two failures, and another success, in that order?
The <literal>context</literal> field can help you correlate a single service&#8217;s updates, and you can order them by <literal>created_at</literal> to see how each one turned out, but that&#8217;s a lot of work.
Fortunately, the API server can do it for you.</simpara>
</section>
<section xml:id="_combined_status">
<title>Combined Status</title>
<simpara><indexterm>
<primary>combined status</primary>
</indexterm><indexterm>
<primary>Commit Status API</primary><secondary>combined status</secondary>
</indexterm>
<indexterm>
<primary>combined status</primary>
</indexterm>If you instead do a GET to <code>/repos/<em>&#x3c;user&#x3e;</em>/<em>&#x3c;repo&#x3e;</em>/<em>&#x3c;ref&#x3e;</em>/status</code> (note that the last word is singular), you&#8217;ll instead get a response that looks like this:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
  "state": "success",
  "statuses": [
    {
      "url": "https://api.github.com/repos/…",
      …
    },
    { … }
  ],
  "sha": "6675aaba883952a1c1b28390866301ee5c281d37",
  "total_count": 2,
  "repository": { … },
  "commit_url": "https://api.github.com/repos/…",
  "url": "https://api.github.com/repos/…"
}</programlisting>
<simpara>The <literal>statuses</literal> array is the result of the logic you&#8217;d probably write if you had to: it collapses the statuses by context, keeping only the last one.
The <literal>state</literal> field contains an overall status that takes into account all of the contexts, providing a final value based on these rules:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Status</entry>
<entry align="left" valign="top">Cause</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><literal>failure</literal></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Any of the contexts posted a <literal>failure</literal> or <literal>error</literal> state</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><literal>pending</literal></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Any of the contexts' latest state is <literal>pending</literal>, or there are no statuses</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><literal>success</literal></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Latest status for every context is <literal>success</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>This is probably exactly what you want, but if you find that your use case calls for different rules, you can always use the <literal>statuses</literal> endpoint to get the raw data and calculate your own combined status.</simpara>
</section>
<section xml:id="_creating_a_status">
<title>Creating a Status</title>
<simpara><indexterm>
<primary>Commit Status API</primary><secondary>creating a status</secondary>
</indexterm>
<indexterm>
<primary>creating a status</primary>
</indexterm>Now obviously these statuses have to come from somewhere.
This API also includes a facility for creating them.
To do this, you simply make a POST request to <code>/repos/<em>&#x3c;user&#x3e;</em>/<em>&#x3c;repo&#x3e;</em>/statuses/<em>&#x3c;sha&#x3e;</em></code>, and supply a JSON object for the fields you want to include with your status:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Field</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><literal>state</literal></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Must be one of <literal>pending</literal>, <literal>success</literal>, <literal>error</literal>, or <literal>failure</literal> (required).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><literal>target_url</literal></literal></simpara></entry>
<entry align="left" valign="top"><simpara>A link to detailed information on the process of deciding what the state is or will be.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><literal>description</literal></literal></simpara></entry>
<entry align="left" valign="top"><simpara>A short string describing what the service is doing to make a decision.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><literal>context</literal></literal></simpara></entry>
<entry align="left" valign="top"><simpara>An application-specific string to allow the API to manage multiple services contributing to a single commit&#8217;s status.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Notice how the last component in that URL is <code><em>&#x3c;sha&#x3e;</em></code>.
While you can query for statuses or a combined status using a ref name (like <literal>master</literal>), creating a status requires you to know the full SHA-1 hash of the commit you want to annotate.
This is to avoid race conditions: if you were targeting a ref, it may have moved between when your process started and when it finished, but the SHA of a commit will never change.<indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-09-commit-status-dotnet-asciidoc1</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-09-commit-status-dotnet-asciidoc1</primary>
</indexterm></simpara>
</section>
</section>
<section xml:id="_lets_write_an_app">
<title>Let&#8217;s Write an App</title>
<simpara><indexterm>
<primary>Commit Status</primary><secondary>example app</secondary><tertiary>id=ix_chapter-09-commit-status-dotnet-asciidoc2</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-09-commit-status-dotnet-asciidoc2</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm><indexterm>
<primary>HTTP server app example</primary><secondary>Commit Status API</secondary><tertiary>id=ix_chapter-09-commit-status-dotnet-asciidoc3</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-09-commit-status-dotnet-asciidoc3</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm>Alright, now that we know how to read and write statuses, let&#8217;s put this API to work.
In this chapter, we&#8217;ll build a simple HTTP service that lets you create commit statuses for repositories you have access to using the OAuth web flow for authorization.
The system we&#8217;ll build will be fairly limited in scope, but it&#8217;s a great starting point to customize for your specific needs.</simpara>
<simpara>The language this time is<indexterm>
<primary>C&#35;</primary>
</indexterm><indexterm>
<primary>CLR (Common Language Runtime)</primary>
</indexterm> C#, running on the CLR (Common Language Runtime).
At one point in the history of computing this wouldn&#8217;t have been a good choice for a book like this, since it was only available on Windows, the development tools cost quite a bit of money, and the language and libraries were fairly limited.
However, with the advent of<indexterm>
<primary>Mono</primary>
</indexterm> Mono (an open source implementation of the .NET runtime), the open sourcing of the CLR core, and the availability of free tools, C# is now a completely valid and rather nice option for open source or hobby developers.
Plus, it has a vibrant ecosystem of packages we can leverage to make our jobs easier.</simpara>
<section xml:id="_libraries">
<title>Libraries</title>
<simpara><indexterm>
<primary>Commit Status API</primary><secondary>libraries for</secondary>
</indexterm>
<indexterm>
<primary>libraries for</primary>
</indexterm><indexterm>
<primary>HTTP server app example</primary><secondary>libraries for</secondary>
</indexterm>
<indexterm>
<primary>libraries for</primary>
</indexterm>You&#8217;ll be happy to know we won&#8217;t be writing an entire HTTP server from scratch in this chapter.
<indexterm>
<primary>Nancy library</primary><secondary>id=ix_chapter-09-commit-status-dotnet-asciidoc4</secondary><tertiary>range=startofrange</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-09-commit-status-dotnet-asciidoc4</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm>There are a number of open source packages that do this work for us, and in this project we&#8217;ll be using Nancy.
<indexterm>
<primary>Sinatra</primary><secondary>and Nancy library</secondary>
</indexterm>
<indexterm>
<primary>and Nancy library</primary>
</indexterm>Nancy is a project that started as a CLR port of the Sinatra framework for Ruby (it takes its name from Frank Sinatra&#8217;s daughter, Nancy).
It&#8217;s very capable, but also very succinct, as you&#8217;ll see.</simpara>
<simpara>We also won&#8217;t be directly implementing access to the GitHub API, because GitHub provides a CLR library for that.
It&#8217;s called octokit.net, and it does all the right things with regard to asynchrony and type safety.
This is the same library used by the GitHub client for Windows, so it&#8217;ll definitely do the job for our little application.
It is, however, the source of a constraint on how we set up our example project: it requires a rather new version of the CLR (4.5) in order to function.
If you want some guidance on how to avoid this pitfall and follow along, continue reading the next section.
If you&#8217;ve worked with Nancy before, and have installed NuGet packages in the past, you might be able to skip to the section labeled <xref linkend="commit_status_first_steps"/>.</simpara>
</section>
<section xml:id="_development_environment">
<title>Development Environment</title>
<simpara><indexterm>
<primary>Commit Status API</primary><secondary>development environment for app</secondary><tertiary>id=ix_chapter-09-commit-status-dotnet-asciidoc5</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-09-commit-status-dotnet-asciidoc5</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm><indexterm>
<primary>HTTP server app example</primary><secondary>development environment for</secondary><tertiary>id=ix_chapter-09-commit-status-dotnet-asciidoc6</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-09-commit-status-dotnet-asciidoc6</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm>If you&#8217;d like to follow along with the code examples, here&#8217;s how to set up a development environment with all the necessary elements.
The process is different on Windows (using Visual Studio) and any other platforms (using Xamarin tools).</simpara>
<section xml:id="_visual_studio">
<title>Visual Studio</title>
<simpara><indexterm>
<primary>Commit Status API</primary><secondary>and Visual Studio</secondary>
</indexterm>
<indexterm>
<primary>and Visual Studio</primary>
</indexterm><indexterm>
<primary>HTTP server app example</primary><secondary>and Visual Studio</secondary>
</indexterm>
<indexterm>
<primary>and Visual Studio</primary>
</indexterm><indexterm>
<primary>Visual Studio</primary>
</indexterm>If you&#8217;re running Windows, you&#8217;ll want to visit <link xl:href="https://www.visualstudio.com/">https://www.visualstudio.com/</link> and download the Community edition of Visual Studio.
The installer will present you with lots of options; for this example, we&#8217;ll only need the "web developer" components, but feel free to check all the boxes that look interesting to you.
(If you have access to a higher tier of Visual Studio, or already have it installed with the web-development packages, you&#8217;re all set.)</simpara>
<simpara>In order to make things just a little smoother, you&#8217;ll want to install a plug-in: the Nancy project templates.
Visit <link xl:href="https://visualstudiogallery.msdn.microsoft.com/">https://visualstudiogallery.msdn.microsoft.com/</link> and search for "nancy.templates."
Choose the search result "Nancy.Templates," which belongs to the NancyFx organization, and click "Get Now."
This should download a <emphasis>.vsix</emphasis> file that you can double-click to install the templates into Visual Studio.</simpara>
<simpara>The next step is to create a new project using one of the newly installed templates.
Go to &#x201c;File&#8594;New Project&#x201d; and select &#x201c;Visual C#&#8594;Web&#8594;Nancy Application with ASP.NET Hosting&#x201d; from the template list (as shown in <xref linkend="vs_new_project"/>).
Make sure the path and name settings at the bottom are to your liking, and click OK.</simpara>
<figure xml:id="vs_new_project">
<title>Creating a Nancy application in Visual Studio</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/btwg_0502.png"/>
</imageobject>
<textobject><phrase>btwg 0502</phrase></textobject>
</mediaobject>
</figure>
<simpara>Next, change the target CLR framework version to something that will work with Octokit.
Right-click the project&#8217;s node in the Solution Explorer, and select &#x201c;Properties.&#x201d;
In the Application section, set Target Framework to be .NET 4.5 (or later), and save.
You may be prompted to reload the solution.</simpara>
<simpara>The very last step is to add NuGet packages for Octokit and Nancy.
Right-click the project node in Solution Explorer, and select &#x201c;Manage NuGet Packages.&#x201d;
Do a search for "Nancy," and upgrade it if necessary&#x2014;there&#8217;s a chance the Nancy project template specifies an out-of-date version.
Then do a search for "Octokit," and install that.
At this point, you should have an empty solution, configured and ready for our example code.
To run it with debugging, go to &#x201c;Debug&#8594;Start Debugging,&#x201d; or hit F5.
Visual Studio will start the server under a debugger, and open an IE instance on <link xl:href="http://localhost:12008/">http://localhost:12008/</link> (the port might be different), which should serve you the default Nancy "404 Not Found" page.</simpara>
</section>
<section xml:id="_xamarin_studio">
<title>Xamarin Studio</title>
<simpara><indexterm>
<primary>Commit Status API</primary><secondary>Xamarin Studio</secondary><tertiary>id=ix_chapter-09-commit-status-dotnet-asciidoc7</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-09-commit-status-dotnet-asciidoc7</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm><indexterm>
<primary>HTTP server app example</primary><secondary>Xamarin Studio</secondary><tertiary>id=ix_chapter-09-commit-status-dotnet-asciidoc8</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-09-commit-status-dotnet-asciidoc8</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm><indexterm>
<primary>Xamarin Studio</primary><secondary>id=ix_chapter-09-commit-status-dotnet-asciidoc9</secondary><tertiary>range=startofrange</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-09-commit-status-dotnet-asciidoc9</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm>On OS X and Linux, as of this writing the easiest way forward is to visit <link xl:href="http://www.monodevelop.com/">http://www.monodevelop.com/</link> and install <indexterm>
<primary>MonoDevelop</primary>
</indexterm>MonoDevelop.
Mono is an open source implementation of Microsoft&#8217;s CLR specification, and MonoDevelop is a development environment that works much like Visual Studio, but is built on Mono, and is completely open source.
If you try to download MonoDevelop on a Windows or OS X machine, you&#8217;ll be prompted to install Xamarin Studio instead; this is a newer version of MonoDevelop with more capabilities, and will work just as well for these examples.</simpara>
<simpara>There are no Nancy-specific project templates for these IDEs, so you&#8217;ll just start with an empty web project.
Go to "File&#8594;New&#8594;Solution," and choose "ASP.NET&#8594;Empty ASP.NET Project" from the template chooser, as shown in <xref linkend="xamarin_new_project"/>.</simpara>
<figure xml:id="xamarin_new_project">
<title>Creating an empty ASP.NET application in Xamarin Studio</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/btwg_0503.png"/>
</imageobject>
<textobject><phrase>btwg 0503</phrase></textobject>
</mediaobject>
</figure>
<simpara>The rest of the wizard steps are about the project name and location; feel free to name and locate this project however you like.</simpara>
<simpara>Next, update the target framework setting.
Control- or right-click the node in the solution explorer that corresponds with your project (<emphasis>not</emphasis> your solution), and select Options from the menu.
Under &#x201c;Build&#8594;General,&#x201d; set the Target Framework to &#x201c;Mono / .NET 4.5&#x201d; (or later) and click OK.</simpara>
<simpara><indexterm>
<primary>NuGet</primary>
</indexterm><indexterm>
<primary>Octokit NuGet</primary>
</indexterm>Lastly, install the Nancy and Octokit NuGet packages.
Go to &#x201c;Project&#8594;Add NuGet Packages&#x201d; in the menu to open the package manager.
Search for Nancy, check the box next to it, search for Octokit, check its box, and click &#x201c;Add Packages&#x201d; at the bottom right.
Once the process is complete, your project is ready for our example code.
To run it under the debugger, go to &#x201c;Run&#8594;Start Debugging,&#x201d; or type ⌘-Enter.
Xamarin will start the server and open a browser window to <link xl:href="http://127.0.0.1:80080">http://127.0.0.1:80080</link> (possibly with a different port), which at this point will just show the default "404 Not Found" page<indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-09-commit-status-dotnet-asciidoc9</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-09-commit-status-dotnet-asciidoc9</primary>
</indexterm><indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-09-commit-status-dotnet-asciidoc8</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-09-commit-status-dotnet-asciidoc8</primary>
</indexterm><indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-09-commit-status-dotnet-asciidoc7</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-09-commit-status-dotnet-asciidoc7</primary>
</indexterm>.<indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-09-commit-status-dotnet-asciidoc6</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-09-commit-status-dotnet-asciidoc6</primary>
</indexterm><indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-09-commit-status-dotnet-asciidoc5</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-09-commit-status-dotnet-asciidoc5</primary>
</indexterm></simpara>
</section>
</section>
<section xml:id="commit_status_first_steps">
<title>Sending the Request</title>
<simpara><indexterm>
<primary>Commit Status API</primary><secondary>sending request</secondary><tertiary>id=ix_chapter-09-commit-status-dotnet-asciidoc10</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-09-commit-status-dotnet-asciidoc10</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm><indexterm>
<primary>HTTP server app example</primary><secondary>sending request</secondary><tertiary>id=ix_chapter-09-commit-status-dotnet-asciidoc11</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-09-commit-status-dotnet-asciidoc11</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm>Alright, now that we have a project ready for some code, let&#8217;s get our Nancy application up and running.
Let&#8217;s be good engineers, and write our tests first.
In order to do this, generate a new unit-test project alongside your existing application project, and add a NuGet reference to the <literal>Nancy.Testing</literal> package.
You can then copy and paste the test examples over the top of the default test module that comes with that template.</simpara>
<simpara>The first thing we&#8217;re going to write is an endpoint that reports how many followers a user has.
In order to test it, we&#8217;ll choose a well-known user and make sure their real name is fetched.
Here&#8217;s what the test code looks like:</simpara>
<programlisting language="csharp" linenumbering="unnumbered">using NUnit.Framework;
using Nancy;
using Nancy.Testing;
using Nancy.Bootstrapper;
using System.Collections.Generic;
using Nancy.Session;

namespace NancyApplication1.Tests
{
  [TestFixture ()]
  public class Test
  {
    private Browser browser;

    [SetUp]
    public void Setup(){
      this.bootstrapper =
        new ConfigurableBootstrapper(with =&gt; {
        with.Module&lt;Handler&gt;();
      });
      this.browser = new Browser (bootstrapper);
    }

    [Test ()]
    public void FetchesUserDetails ()
    {
      var result = this.browser.Get ("/mojombo", <co xml:id="CO1-1"/>
        with =&gt; with.HttpRequest ());
      Assert.AreEqual (HttpStatusCode.OK, result.StatusCode);
      Assert.IsTrue (result.Body.AsString()
        .Contains("Tom Preston-Werner")); <co xml:id="CO1-2"/>
    }
  }
}</programlisting>
<calloutlist>
<callout arearefs="CO1-1">
<para>Here we&#8217;re using the <literal>Browser</literal> class provided by Nancy.Testing to make a request to <literal>/mojombo</literal>, which should give us the number of likes for that GitHub user.</para>
</callout>
<callout arearefs="CO1-2">
<para>Here we&#8217;re asserting that mojombo&#8217;s real name is fetched by the endpoint.</para>
</callout>
</calloutlist>
<simpara>Now that we have a failing test, let&#8217;s write the code to implement that endpoint in Nancy.
Here&#8217;s what the initial version of that file will look like:</simpara>
<programlisting language="csharp" linenumbering="unnumbered">using Nancy;
using Octokit;
using System;
using System.Collections.Generic;
using System.Linq;

namespace NancyApp
{
    public class Handler : NancyModule <co xml:id="CO2-1"/>
    {
        private readonly GitHubClient client =
            new GitHubClient(new ProductHeaderValue("MyHello")); <co xml:id="CO2-2"/>

        public Handler()
        {
            Get["/{user}", true] = async (parms, ct) =&gt; <co xml:id="CO2-3"/>
                {
                    var user = await client.User.Get(parms.user.ToString()); <co xml:id="CO2-4"/>
                    return String.Format("{0} people love {1}!",
                                         user.Followers, user.Name); <co xml:id="CO2-5"/>
                };
        }
    }
}</programlisting>
<calloutlist>
<callout arearefs="CO2-1">
<para>Here we derive a class from <literal>NancyModule</literal>, which is all you have to do to start receiving and processing HTTP requests in Nancy.</para>
</callout>
<callout arearefs="CO2-2">
<para>The <literal>GitHubClient</literal> class is the entry point for Octokit.
Here we create an instance we&#8217;ll use later on, using a placeholder product name&#x2014;this name will not be used for the APIs we&#8217;ll be accessing.</para>
</callout>
<callout arearefs="CO2-3">
<para>The module&#8217;s constructor needs to set up route mappings.
We map <literal>/{user}</literal> to a lambda function using the <literal>Get</literal> dictionary that comes with <literal>NancyModule</literal>.
The second parameter to the index operator says that the handler will be asynchronous.</para>
</callout>
<callout arearefs="CO2-4">
<para>Here we see how to get the <literal>{user}</literal> part of the request URL (it comes as a property on the <literal>parms</literal> parameter), and how to query the GitHub User API using Octokit.
Note that we have to <literal>await</literal> the result of the network query, since it may take some time.</para>
</callout>
<callout arearefs="CO2-5">
<para>Nancy request handlers can simply return a text string, which will be marked as HTML for the viewing browser.
Here we return a simple string with the user&#8217;s name and number of followers.</para>
</callout>
</calloutlist>
<note>
<simpara>The<indexterm>
<primary>async keyword</primary>
</indexterm><indexterm>
<primary>await keyword</primary>
</indexterm> <literal>async</literal> and <literal>await</literal> keywords bear special mention.
These comprise a syntactic nicety that encapsulates a series of functions that are running on an event loop.
The code looks like it runs in order, but really when the <literal>await</literal> keyword is reached, the system starts an asynchronous request, and returns control back to the main event loop.
Once the request has finished, and the promise is fulfilled, the event loop will then call back into the code that&#8217;s expecting the return value of the <literal>await</literal> keyword, with all the scope variables intact.
This feature was introduced in .NET 4.0 (which was released in 2012), and it lets you write asynchronous code almost as though it were synchronous.
This is but one of the features that make C# the favorite of many developers.</simpara>
</note>
<simpara>This example is a bit more complicated than "hello, world," but it&#8217;s still fairly succinct and clear.<indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-09-commit-status-dotnet-asciidoc11</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-09-commit-status-dotnet-asciidoc11</primary>
</indexterm><indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-09-commit-status-dotnet-asciidoc10</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-09-commit-status-dotnet-asciidoc10</primary>
</indexterm>
This bodes well, because we&#8217;re about to introduce some complexity, in the form of OAuth.</simpara>
</section>
<section xml:id="_oauth_flow">
<title>OAuth Flow</title>
<simpara><indexterm>
<primary>Commit Status API</primary><secondary>OAuth flow</secondary><tertiary>id=ix_chapter-09-commit-status-dotnet-asciidoc12</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-09-commit-status-dotnet-asciidoc12</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm><indexterm>
<primary>OAuth</primary><secondary>flow for Commit Status API</secondary><tertiary>id=ix_chapter-09-commit-status-dotnet-asciidoc13</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-09-commit-status-dotnet-asciidoc13</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm>In order to post a status update for a commit, we&#8217;re going to have to ask the user for permission.
Apart from asking for their username and password (which gives way too much control, and if two-factor authentication is enabled may not even be enough), the only way to do this is OAuth, which isn&#8217;t entirely straightforward.</simpara>
<simpara><indexterm>
<primary>OAuth</primary><secondary>authorization process outline</secondary>
</indexterm>
<indexterm>
<primary>authorization process outline</primary>
</indexterm>Here&#8217;s a simple outline of the OAuth process, from our little server&#8217;s point of view:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>We need an authorization token, either because we don&#8217;t have one, or because the one we have is expired.
This is just a string of characters, but we can&#8217;t generate it ourselves, so we ask GitHub for one.
This involves redirecting the user&#8217;s browser to a GitHub API endpoint, with the kind of permission we&#8217;re asking for and some other details as query parameters.</simpara>
</listitem>
<listitem>
<simpara>GitHub tells the user (through their browser) that an application is requesting some permissions, and they can either allow or deny them.</simpara>
</listitem>
<listitem>
<simpara>If the user allows this access, their browser is redirected to a URL we specified in step 1.
A "code" is passed as a query parameter; this is not the access token we want, but a time-limited key to get one.</simpara>
</listitem>
<listitem>
<simpara>From inside the handler for this request, we can use a REST API to get the actual OAuth access token, which we can store somewhere safe.
We do this because if we already have a token, we can skip all the way to the last step of this process.</simpara>
</listitem>
<listitem>
<simpara>Now we have permission, and we can use the GitHub API in authenticated mode.</simpara>
</listitem>
</orderedlist>
<simpara>This might seem overly complicated, but its design achieves several goals.
First, permission can be scoped&#x2014;an application is almost never given full access to the user&#8217;s account and data.
Second, the whole exchange is secure; at least one part of this has to go through the user, and cannot be automated.
Third, the access token is never transmitted to the user&#8217;s browser, which avoids an entire class of security vulnerabilities.</simpara>
<simpara>Let&#8217;s walk through the code for our tiny little server&#8217;s implementation of this flow.
First, once we have a token, we should store it so we&#8217;re not going through the entire redirect cycle for every user request.
We&#8217;re going to store it in a cookie (though since this goes back and forth to the user&#8217;s browser, a production application would probably use a database).
Nancy can help us with this, but first we have to enable it, and the way this is accomplished is by using a bootstrapper.
We&#8217;re going to add this class to our application:</simpara>
<programlisting language="csharp" linenumbering="unnumbered">using Nancy;
using Nancy.Bootstrapper;
using Nancy.Session;
using Nancy.TinyIoc;

namespace NancyApp
{
    public class Bootstrapper : DefaultNancyBootstrapper
    {
        protected override void ApplicationStartup(TinyIoCContainer container,
                                                   IPipelines pipelines)
        {
            CookieBasedSessions.Enable(pipelines);
        }
    }
}</programlisting>
<simpara>Nancy will automatically detect a bootstrapper class, and use it to initialize our server.
Now, from within a <literal>NancyModule</literal>, we can use the<indexterm>
<primary>Session property</primary>
</indexterm> <literal>Session</literal> property to store and retrieve values that are transmitted as cookies.</simpara>
<simpara>Next, we have to include our application&#8217;s ID and secret in some of the requests, so we embed them in the code by adding these fields to the <literal>Handler</literal> class.
If you don&#8217;t have an application, visit <link xl:href="https://github.com/settings/developers">https://github.com/settings/developers</link> to create one and use <literal><link xl:href="http://localhost:8080/authorize">http://localhost:8080/authorize</link></literal> (depending in your environment, the port number might be slightly different) for the callback URL&#x2014;we&#8217;ll see why in a bit:</simpara>
<programlisting language="csharp" linenumbering="unnumbered">        private const string clientId = "&lt;clientId&gt;";
        private const string clientSecret = "&lt;clientSecret&gt;";</programlisting>
<simpara>Obviously, you should use values from your own API application if you&#8217;re following along.</simpara>
<simpara>After that, we&#8217;ll need a helper method that kicks off the OAuth process:</simpara>
<programlisting language="csharp" linenumbering="unnumbered">private Response RedirectToOAuth()
{
    var csrf = Guid.NewGuid().ToString();
    Session["CSRF:State"] = csrf; <co xml:id="CO3-1"/>
    Session["OrigUrl"] = this.Request.Path; <co xml:id="CO3-2"/>

    var request = new OauthLoginRequest(clientId)
        {
            Scopes = { "repo:status" }, <co xml:id="CO3-3"/>
            State = csrf,
        };
    var oauthLoginUrl = client.Oauth.GetGitHubLoginUrl(request);
    return Response.AsRedirect(oauthLoginUrl.ToString()); <co xml:id="CO3-4"/>
}</programlisting>
<calloutlist>
<callout arearefs="CO3-1">
<para>CSRF stands for <emphasis>cross-site request forgery</emphasis>.
This is a mechanism by which we can be sure the OAuth request process really did originate from our site.
The GitHub OAuth API will pass this value back to us when the user authorizes access, so we store it in the cookie for later reference.</para>
</callout>
<callout arearefs="CO3-2">
<para>Storing the original URL in the session cookie is a UX feature; once the OAuth process has completed, we want to send the user back to what they were trying to do in the first place.</para>
</callout>
<callout arearefs="CO3-3">
<para><literal>repo:status</literal> is the permission set we&#8217;re asking for.
Note that we&#8217;re also including our CSRF token in this object; this is so GitHub can give it back to us later for verification.</para>
</callout>
<callout arearefs="CO3-4">
<para>Here we use Octokit to generate the redirect URL, and send the user&#8217;s browser there.</para>
</callout>
</calloutlist>
<simpara><literal>RedirectToOAuth</literal> <indexterm>
<primary>RedirectToOAuth method</primary>
</indexterm>is a method that can be called from any route handler in our module, if it&#8217;s discovered that the token is missing or invalid.
We&#8217;ll see how it&#8217;s called a bit later, but for now let&#8217;s follow the rest of the OAuth process.</simpara>
<simpara>In our GitHub application settings, we specified an authorization URL.
In this case, we&#8217;ve specified <literal><link xl:href="http://localhost:8080/authorize">http://localhost:8080/authorize</link></literal>, and that&#8217;s where GitHub will redirect the user&#8217;s browser if they decide to grant our application the permissions it&#8217;s asking for.
Here&#8217;s the handler for that endpoint, which has been inserted into the module constructor:</simpara>
<programlisting role="pagebreak-before" language="csharp" linenumbering="unnumbered">Get["/authorize", true] = async (parms, ct) =&gt; <co xml:id="CO4-1"/>
    {
        var csrf = Session["CSRF:State"] as string;
        Session.Delete("CSRF:State");
        if (csrf != Request.Query["state"]) <co xml:id="CO4-2"/>
        {
            return HttpStatusCode.Unauthorized;
        }

        var queryCode = Request.Query["code"].ToString();
        var tokenReq =  new OauthTokenRequest(clientId, <co xml:id="CO4-3"/>
                                              clientSecret,
                                              queryCode);
        var token = await client.Oauth.CreateAccessToken(tokenReq);
        Session["accessToken"] = token.AccessToken; <co xml:id="CO4-4"/>

        var origUrl = Session["OrigUrl"].ToString();
        Session.Delete("OrigUrl");
        return Response.AsRedirect(origUrl); <co xml:id="CO4-5"/>
    };</programlisting>
<calloutlist>
<callout arearefs="CO4-1">
<para>This is how you map paths to handler functions in Nancy.
Any class that derives from <literal>NancyModule</literal> has an indexable object for every HTTP verb, and you can attach a synchronous or asynchronous handler to any one of them.
There are also ways to include dynamic portions of URLs, which we&#8217;ll see later on.</para>
</callout>
<callout arearefs="CO4-2">
<para>Here we verify the CSRF token we generated before.
If it doesn&#8217;t match, something shady is happening, so we return a 401.</para>
</callout>
<callout arearefs="CO4-3">
<para>This is the REST call that converts our OAuth code to an access token.
In order to verify that this really is our application asking for the token, we pass in both the client ID and secret, as well as the code given to us by GitHub.</para>
</callout>
<callout arearefs="CO4-4">
<para>This is where we store the resulting token in the session cookie.
Again, this wouldn&#8217;t be a good idea for a real application, but for our purposes it&#8217;ll do.</para>
</callout>
<callout arearefs="CO4-5">
<para>Here we redirect the user back to what they were originally trying to do, with as little disruption as possible.</para>
</callout>
</calloutlist>
<simpara>This last endpoint is something we can test, but we&#8217;ll need to be able to handle sessions.
In order to do that, we&#8217;ll add this snippet to our test project&#8217;s namespace:</simpara>
<programlisting language="csharp" linenumbering="unnumbered">public static class BootstrapperExtensions
{
  public static void WithSession(this IPipelines pipeline,
                                       IDictionary&lt;string, object&gt; session)
  {
    pipeline.BeforeRequest.AddItemToEndOfPipeline(ctx =&gt;
      {
        ctx.Request.Session = new Session(session);
        return null;
      });
  }
}</programlisting>
<simpara>This is <indexterm>
<primary>extension methods</primary>
</indexterm>an <emphasis>extension method</emphasis> that allows us to provide a <literal>Session</literal> object for a request, something the CSRF handling uses.
Now that that exists, we can add a test method to our test-suite class:</simpara>
<programlisting language="csharp" linenumbering="unnumbered">[Test]
public void HandlesAuthorization()
{
  // Mismatched CSRF token
  bootstrapper.WithSession(new Dictionary&lt;string, object&gt; {
    { "CSRF:State", "sometoken" },
  });
  var result = this.browser.Get ("/authorize", (with) =&gt; {
    with.HttpRequest();
    with.Query("state", "someothertoken");
  });
  Assert.AreEqual (HttpStatusCode.Unauthorized, result.StatusCode);

  // Matching CSRF token
  bootstrapper.WithSession(new Dictionary&lt;string, object&gt; {
    { "CSRF:State", "sometoken" },
                { "OrigUrl", "http://success" },
  });
  result = this.browser.Get ("/authorize", (with) =&gt; {
    with.HttpRequest();
    with.Query("state", "sometoken");
  });
  result.ShouldHaveRedirectedTo ("http://success");
}</programlisting>
<simpara>The first part sets up a mismatched CSRF token; it&#8217;s <literal>"sometoken"</literal> in the session (which is set before the API call is made), and <literal>"someothertoken"</literal> in the request (which should be sent from GitHub), so we assert that the status code is 401.
The second part has matching tokens, so we assert that the response is a redirect to the URL we stored in the session.</simpara>
<simpara>Once all that is done, we&#8217;ve got our token and are able to continue on our merry way.
All our handlers have to do to trigger an OAuth sequence is to call <literal>RedirectToOAuth()</literal> if it&#8217;s necessary, and we&#8217;ll automatically return the user to where they were when the process completes.<indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-09-commit-status-dotnet-asciidoc13</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-09-commit-status-dotnet-asciidoc13</primary>
</indexterm><indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-09-commit-status-dotnet-asciidoc12</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-09-commit-status-dotnet-asciidoc12</primary>
</indexterm></simpara>
</section>
<section xml:id="_status_handler">
<title>Status Handler</title>
<simpara><indexterm>
<primary>Commit Status API</primary><secondary>status handler</secondary><tertiary>id=ix_chapter-09-commit-status-dotnet-asciidoc14</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-09-commit-status-dotnet-asciidoc14</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm><indexterm>
<primary>status handler</primary><secondary>id=ix_chapter-09-commit-status-dotnet-asciidoc15</secondary><tertiary>range=startofrange</tertiary>
</indexterm>
<indexterm>
<primary>id=ix_chapter-09-commit-status-dotnet-asciidoc15</primary><secondary>range=startofrange</secondary>
</indexterm>
<indexterm>
<primary>range=startofrange</primary>
</indexterm>Having gone through all that OAuth business, we should now have a token that grants us permission to create commit statuses.
We&#8217;re going to add this handler to our Nancy module constructor:</simpara>
<programlisting language="csharp" linenumbering="unnumbered">Get["/{user}/{repo}/{sha}/{status}", true] = async (parms, ct) =&gt; <co xml:id="CO5-1"/>
    {
        var accessToken = Session["accessToken"] as string;
        if (string.IsNullOrEmpty(accessToken))
            return RedirectToOAuth(); <co xml:id="CO5-2"/>
        client.Credentials = new Credentials(accessToken);

        CommitState newState = Enum.Parse(typeof(CommitState), <co xml:id="CO5-3"/>
                                          parms.status,
                                          true);
        try
        {
            var newStatus = new NewCommitStatus <co xml:id="CO5-4"/>
            {
                State = newState,
                Context = "example-api-app",
                TargetUrl = new Uri(Request.Url.SiteBase),
            };
            await client.Repository.CommitStatus.Create(parms.user, <co xml:id="CO5-5"/>
                                                        parms.repo,
                                                        parms.sha,
                                                        newStatus);
        }
        catch (NotFoundException) <co xml:id="CO5-6"/>
        {
            return HttpStatusCode.NotFound;
        }

        var template = @"Done! Go to &lt;a href=""https://" <co xml:id="CO5-7"/>
        + @"api.github.com/repos/{0}/{1}/commits/{2}/status"
        + @"""&gt;this API endpiont&lt;/a&gt;";
        return String.Format(template,
                             parms.user, parms.repo, parms.sha);
    };</programlisting>
<calloutlist>
<callout arearefs="CO5-1">
<para>Note the request path for this handler: a GET request to <code>localhost:8080/user/repo/<em>&#x3c;sha&#x3e;</em>/<em>&#x3c;status&#x3e;</em></code> will create a new status.
This is easy to test with the browser, but also makes it easy for web crawlers to unknowingly trigger this API.
For this example it&#8217;s okay, but for a real application you&#8217;d probably want to require this to be a POST request.</para>
</callout>
<callout arearefs="CO5-2">
<para>Here&#8217;s where our OAuth helper comes in.
We redirect through the OAuth flow if the session cookie doesn&#8217;t have an authorization token.
It&#8217;s not shown here, but we&#8217;d also want to do this if we get an authorization exception from any of the Octokit APIs.</para>
</callout>
<callout arearefs="CO5-3">
<para>Here we&#8217;re trying to parse the last segment of the request URL into a member of the <literal>CommitState</literal> enumeration.
Octokit tries to maintain type safety for all of its APIs, so we can&#8217;t just use the raw string.</para>
</callout>
<callout arearefs="CO5-4">
<para>The <literal>NewCommitStatus</literal> object encapsulates all the things you can set when creating a new status.
Here we set the state we parsed earlier, a (hopefully) unique context value that identifies our service, and a not-very-useful target URL (which should really go to an explanation of how the result was derived).</para>
</callout>
<callout arearefs="CO5-5">
<para>This is the REST call to create the new status.
It&#8217;s an <literal>async</literal> method, which means we have to <literal>await</literal> the result before we can do anything with it.</para>
</callout>
<callout arearefs="CO5-6">
<para>There are a number of exceptions that could be thrown from the API, but the biggest one we want to handle is the <literal>NotFoundException</literal>, which has been translated from the HTTP 404 status.
Here we translate it back to make for a nice(r) experience for the user.</para>
</callout>
<callout arearefs="CO5-7">
<para>If we succeed, we render a snippet of HTML and return it from our handler.
Nancy sets the response&#8217;s <literal>content-type</literal> to <literal>text/html</literal> by default, so the user will get a nice clickable link.</para>
</callout>
</calloutlist>
<simpara>That&#8217;s it!
If you&#8217;ve typed all this into a project of your own, you should be able to run it under the debugger, or host it in an ASP.NET server, and create commit statuses for your projects by opening URLs in your browser.<indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-09-commit-status-dotnet-asciidoc15</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-09-commit-status-dotnet-asciidoc15</primary>
</indexterm></simpara>
<simpara>We noted this a bit earlier, but it bears repeating: this particular example responds to GET requests for ease of testing, but for a real service like this you&#8217;d probably want creation of statuses to use a POST request<indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-09-commit-status-dotnet-asciidoc14</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-09-commit-status-dotnet-asciidoc14</primary>
</indexterm><indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-09-commit-status-dotnet-asciidoc4</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-09-commit-status-dotnet-asciidoc4</primary>
</indexterm>.<indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-09-commit-status-dotnet-asciidoc3</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-09-commit-status-dotnet-asciidoc3</primary>
</indexterm><indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-09-commit-status-dotnet-asciidoc2</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-09-commit-status-dotnet-asciidoc2</primary>
</indexterm></simpara>
</section>
</section>
<section xml:id="_summary">
<title>Summary</title>
<simpara>Even if you haven&#8217;t written a lot of code during this chapter, you&#8217;ve learned a lot of concepts.</simpara>
<simpara>You&#8217;ve seen the Commit Status API, and you&#8217;ve seen how it&#8217;s used by continuous integration software, but you know that it can be used for much more.
You can read and write statuses, and you know how the API server coalesces many statuses into a single pass/fail value, and you also know how to write your own multistatus calculation if the default one doesn&#8217;t meet your needs.
You also know what&#8217;s behind the green checkmarks and red Xs you see in your pull requests.</simpara>
<simpara>You&#8217;ve learned how the OAuth web flow works, and why it&#8217;s designed the way it is.
OAuth is the key to many other capabilities of the GitHub API, and it&#8217;s the right thing to do with regards to trust and permissions.
This will allow you to write truly world-class GitHub-interfacing applications, whether running on the Web or on a user&#8217;s device.</simpara>
<simpara>You&#8217;ve gained a passing knowledge of C#, including its package system, at least one IDE, lambda functions, object initializers, and more.
C# really is a nice language, and if you use it for a while, you&#8217;ll probably miss some of its features if you write in anything else.</simpara>
<simpara>You&#8217;ve seen NuGet, the .NET package manager, and had a peek at the multitudes of packages in this ecosystem.
The capability you have here is astounding; libraries exist for many common activities, and lots of uncommon ones too, so no matter what you need to do, you&#8217;re likely to find a NuGet package to help you do it.</simpara>
<simpara>You&#8217;ve learned about Nancy, with which you can quickly build any HTTP service, from a REST API to an HTML-based interface, and all with a compact syntax and intuitive object model.
If you&#8217;ve never been exposed to the Sinatra view of the world, this probably makes you think about web servers a bit differently, and if you have, you&#8217;ll have a new appreciation for how this model can be idiomatically implemented.</simpara>
<simpara>And you&#8217;ve had an introduction to Octokit, a type-safe implementation of a REST API, with built-in asynchrony and OAuth helpers.
This toolkit really does make working with the GitHub API as simple and straightforward as using any .NET library, including the ability to explore it using Intellisense.<indexterm>
<primary>range=endofrange</primary><secondary>startref=ix_chapter-09-commit-status-dotnet-asciidoc0</secondary>
</indexterm>
<indexterm>
<primary>startref=ix_chapter-09-commit-status-dotnet-asciidoc0</primary>
</indexterm></simpara>
<simpara>Now it&#8217;s time to switch back to Ruby.
In our next chapter, we&#8217;ll take a look at Jekyll (which is what really runs GitHub Pages), and how to use it to write a blog.</simpara>
</section>
</section>
</article>