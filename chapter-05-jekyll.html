<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Building Tools with GitHub | The book “Building Tools with GitHub” originally published by O’Reilly. By Chris Dawson with Ben Straub.</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Building Tools with GitHub" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The book “Building Tools with GitHub” originally published by O’Reilly. By Chris Dawson with Ben Straub." />
<meta property="og:description" content="The book “Building Tools with GitHub” originally published by O’Reilly. By Chris Dawson with Ben Straub." />
<link rel="canonical" href="https://buildingtoolswithgithub.teddyhyde.io/chapter-05-jekyll.html" />
<meta property="og:url" content="https://buildingtoolswithgithub.teddyhyde.io/chapter-05-jekyll.html" />
<meta property="og:site_name" content="Building Tools with GitHub" />
<script type="application/ld+json">
{"description":"The book “Building Tools with GitHub” originally published by O’Reilly. By Chris Dawson with Ben Straub.","@type":"WebPage","url":"https://buildingtoolswithgithub.teddyhyde.io/chapter-05-jekyll.html","headline":"Building Tools with GitHub","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=">
  
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-127650375-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-127650375-2');
</script>

</head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="https://buildingtoolswithgithub.teddyhyde.io/">Building Tools with GitHub</a></h1>
      

      <div class="sect1">
<h2 id="Jekyll">Ruby and Jekyll</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Jekyll project calls itself a "blog-aware, static site generator
in Ruby." At its core, Jekyll is a very simple set of
technologies for building websites. Simplicity is what gives Jekyll
its power: using Jekyll you will never have to learn about database
backends, complicated server installations, or any of the myriad
processes involved with most monolithic website technologies. Many
prominent technical bloggers use Jekyll as their blogging platform.</p>
</div>
<div class="paragraph">
<p>Like many of the open source technologies in heavy usage at GitHub,
Jekyll was originally developed by Tom Preson Warner, one of the
cofounders of GitHub, and Nick Quaranto, of 37 Signals, though there
are now thousands of contributors to the Jekyll codebase.
Unsurprisingly, the strength of the Jekyll tool comes not from the
brilliance of the original developers or the brilliance of the idea,
but the way those original developers cultivated community and
involvement among their users.</p>
</div>
<div class="sect2">
<h3 id="learning-and-building-with-jekyll">Learning and Building with Jekyll</h3>
<div class="paragraph">
<p>In this chapter we will investigate the structure of a Jekyll blog,
illustrating the few major technology pieces involved. Once we have
familiarized ourselves with Jekyll, we will then create a Jekyll blog
from scratch using the command-line tools. Then we will write a Ruby
program that scrapes a blog-like website and converts the scraped
information into a new Jekyll blog.</p>
</div>
</div>
<div class="sect2">
<h3 id="what-is-jekyll">What Is Jekyll?</h3>
<div class="paragraph">
<p>Jekyll specifies a file structure format: conform to this format and
Jekyll will compile your files into HTML. Jekyll builds on top of two
proven tools: Markdown, a markup language that is surprisingly
readable and expressive, and Liquid Markup, a simple programming language that
gives you just enough components to build modern web
pages requiring conditionals and loops, but safe enough that you can
run untrusted pages on public servers. With these two technologies and
agreement on a layout structure, Jekyll can build very complicated websites paradoxically without requiring a complicated structure of files
and technologies.</p>
</div>
<div class="paragraph">
<p>Jekyll works natively with GitHub because a Jekyll blog is
stored as a Git repository. When you push files into GitHub from a
repository GitHub recognizes as a Jekyll site, GitHub
automatically rebuilds the site for you.
Jekyll is an open source generator and defines a format for your
source files, a format other tools can easily understand and
operate upon. This means you can build your own tools to interact with
a Jekyll blog. Combining an open source tool like Jekyll with a well-written API like the GitHub API makes for some powerful publishing
tools.</p>
</div>
<div class="sect3">
<h4 id="operating-jekyll-locally">Operating Jekyll Locally</h4>
<div class="paragraph">
<p>To really use Jekyll, you&#8217;ll need the <code>jekyll</code> gem. As we explain in
<a href="#appendix">[appendix]</a>, we could install a ruby gem using this command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ gem install jekyll</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are two issues with installing this way. The first is that any
commands we run inside the command line are lost to us and the world
(other than in our private shell history file). The second is that if
we are going to publish any of our sites to GitHub, we will want to
make sure we are matching the exact versions of Jekyll and its
dependencies so that a site that works on our local laptop also works
when published into GitHub. If you don&#8217;t take care of this, you&#8217;ll
occasionally get an email like this from GitHub:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text"> The page build failed with the following error:

 page build failed

 For information on troubleshooting Jekyll see
 https://help.github.com/articles/using-jekyll-with-pages#troubleshooting
 If you have any questions please contact GitHub Support.</code></pre>
</div>
</div>
<div class="paragraph">
<p>The fix for these two issues is a simple one. You&#8217;ve probably seen other
chapters using a <code>Gemfile</code> to install Ruby libraries. Instead of
using a manual command like <code>bundle</code> to install from the command line,
let&#8217;s put this dependency into the Gemfile. Then, anyone else using
this repository can run the command <code>bundle install</code> and install the
correct dependencies. And instead of using the <code>jekyll</code> gem directly, use the
<code>github-pages</code> gem, which synchronizes your Jekyll gem versions with
those on GitHub. If you do get the preceding email, run the command <code>bundle update</code>
to make sure that everything is properly set up and synchronized and
generally this will reproduce the issues on your local setup, which is
a much faster place to fix them:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ printf "gem 'github-pages' &gt;&gt; Gemfile
$ bundle install</code></pre>
</div>
</div>
<div class="paragraph">
<p>Creating and managing your dependencies inside a Gemfile is the smart
way to get your Jekyll tool synced with the version running on GitHub.</p>
</div>
<div class="paragraph">
<p>Now we are ready to create a Jekyll blog.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jekyll-blog-quick-start">Jekyll Blog Quick Start</h3>
<div class="paragraph">
<p>We have our required tools installed, so let&#8217;s create a simple blog. Run
these commands:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ jekyll new myblog
$ cd myblog</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>jekyll new</code> command creates the necessary structure for a
minimal Jekyll blog. Taking a look inside the directory, you&#8217;ll see a
few files that comprise the structure of a basic Jekyll blog.</p>
</div>
<div class="paragraph">
<p>The <code>jekyll new</code> command installs two CSS files: one for
the blog (<em>main.css</em>) and one for syntax highlighting (<em>syntax.css</em>).
Remember, you are in full control of this site; the <em>main.css</em> file is
simply boilerplate, which you can completely throw away if it does not
suit your needs. The syntax file helps when including code snippets
and contains syntax highlighting CSS that prettifies many programming
languages.</p>
</div>
<div class="paragraph">
<p>Installation of a new blog comes with a <em>.gitignore</em> file as well that contains one entry: <em>_site</em>. When you use the Jekyll library to build your site locally, all files are by default built into the <em>_site</em> directory. This <em>.gitignore</em> file prevents those files from being included inside your repository as they are overwritten by the Jekyll command on GitHub when your files are pushed up to GitHub.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>jekyll new</code> command does not create or initialize a new Git
repository for you with your files. If you want to do this, you will need to
use the <code>git init</code> command. The Jekyll initialization command does create the
proper structure for you to easily add all files to a Git repository;
just use <code>git add .; git commit</code> and your <em>.gitignore</em> file will be added
and configure your repository to ignore unnecessary files like the
<em>_site</em> directory.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>All your blog posts are stored in the <em>_posts</em> directory. Jekyll sites
are not required to have a <em>_posts</em> directory (you can use Jekyll with
any kind of static site) but if you do include files in this directory
Jekyll handles them in a special way. If you look in the <em>_posts</em>
directory now, you see that the Jekyll initialization command has
created <span class="keep-together">your first</span> post for you, something like
<em>_posts/2014-03-03-welcome-to-jekyll.Markdown</em>. These posts have a
special naming format: the title of the post (with any whitespace replaced with
hyphens) trailed by the date and then an extension (either <em>.Markdown</em>
or <em>.md</em> for Markdown files, or <em>.textile</em> for Textile).</p>
</div>
<div class="paragraph">
<p>Your new Jekyll blog also comes with a few HTML files: an <em>index.html</em> file,
which is the starting point for your blog, and several layout files,
which are used as wrappers when generating your content. If you look
in the <em>_layouts</em> directory, notice there is a file named
<em>default.html</em> and another named <em>post.html</em>. These files are the
layout files, files that are wrapped around all generated content,
like those from your Markdown-formatted blog posts. For
example, the <em>post.html</em> file is wrapped around the generated content
of each file stored inside the <em>_posts</em> directory. First, the markup content is
turned into HTML and then the layout wrapper is applied. If you look
inside each of the files inside the <em>_layouts</em> directory, you will see
that each contains a placeholder with <code>{{ content }}</code>. This
placeholder is replaced with the generated content from other files.</p>
</div>
<div class="paragraph">
<p>These placeholders are actually a markup language on their own:
<em>Liquid Markup</em>. Liquid Markup was developed and open sourced by
Shopify.com. Liquid Markup arose from a desire to have a safe way
to host programmatic constructs (like loops and variables) inside a
template, without exposing the rendering context
to a full-fledged programming environment. Shopify wanted to create a
way for untrusted users of its public-facing systems to upload
dynamic content but not worry that the markup language would permit
malicious activity; for example, given a full-fledged embedded
programming language, Shopify would open itself to attack if a user
wrote code to open network connections to sites on its internal
networks. Templating languages like PHP or ERB (embedded Ruby
templates, popular with the Ruby on Rails framework) allow fully
embedded code snippets, and while this is very powerful when you have full control
over your source documents, it can be dangerous to provide a mechanism
where that embedded code could look like <code>system("rm -rf /")</code>.
Liquid Markup provides many of the benefits of embedded programming templates,
without the dangers. We will show several examples of Liquid Markup
and how they work later in the chapter.</p>
</div>
<div class="paragraph">
<p>Lastly, your Jekyll directory has a special file called <em>_config.yml</em>.
This is the Jekyll configuration file. Peering into it, you&#8217;ll see it
is very basic:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">name: Your New Jekyll Site
markdown: redcarpet
highlighter: pygments</code></pre>
</div>
</div>
<div class="paragraph">
<p>We only have three lines to contend with and they are simple to
understand: the name of our site, the Markdown parser used by our
Jekyll command, and whether to use <code>pygments</code> to do syntax highlighting.</p>
</div>
<div class="paragraph">
<p>To view this site locally run this command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ jekyll serve</code></pre>
</div>
</div>
<div class="paragraph">
<p>This command builds the entirety of your Jekyll directory, and then
starts a mini web server to serve the files up to you. If you then
visit <em><a href="http://localhost:4000" class="bare">http://localhost:4000</a></em> in your web browser, you will see
something on the front page of your site and a single blog post listed in
the index, as shown in <a href="#bare-jekyll-site">A bare Jekyll site</a>.</p>
</div>
<div id="bare-jekyll-site" class="imageblock">
<div class="content">
<img src="images/btwg_0601.png" alt="btwg 0601">
</div>
<div class="title">Figure 1. A bare Jekyll site</div>
</div>
<div class="paragraph">
<p>Clicking into the link inside the "Blog Posts" section, you will then
see your first post, as in <a href="#a-sample-post">A sample post</a>.</p>
</div>
<div id="a-sample-post" class="imageblock">
<div class="content">
<img src="images/btwg_0602.png" alt="btwg 0602">
</div>
<div class="title">Figure 2. A sample post</div>
</div>
<div class="paragraph">
<p>Our Jekyll initialization command created this new post for us. This page
is backed by the Markdown file inside the <em>_posts</em> directory we saw earlier:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">---
layout: post
title:  "Welcome to Jekyll!"
date:   2014-03-03 12:56:40
categories: jekyll update
---</code></pre>
</div>
</div>
<div class="paragraph">
<p>You&#8217;ll find this post in your <em>_posts</em> directory&#x2014;edit this
post and rebuild (or run with the <code>-w</code> switch) to see your changes!
To add new posts, simply add a file in the <em>_posts</em> directory
that follows the convention: YYYY-MM-DD-name-of-post.ext.</p>
</div>
<div class="paragraph">
<p>Jekyll also offers powerful support for code snippets:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-liquid" data-lang="liquid">{% highlight ruby %}
def print_hi(name)
  puts "Hi, #{name}"
end
print_hi('Tom')
#=&gt; prints 'Hi, Tom' to STDOUT.
{% endhighlight %}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Check out the <a href="http://jekyllrb.com">Jekyll docs</a> for more info on how to get
the most out of Jekyll. File all bugs/feature requests at
<a href="https://github.com/mojombo/jekyll">Jekyll&#8217;s GitHub repo</a>.</p>
</div>
<div class="paragraph">
<p>Hopefully you agree that this is a fairly intuitive and readable
alternative to raw HTML. This simplicity and readability is one of the
major benefits of using Jekyll. Your source files maintain a
readability that allows you to focus on the content itself, not on the
technology that will eventually make them beautiful. Let&#8217;s go over
this file and investigate some of the important pieces.</p>
</div>
<div class="sect3">
<h4 id="yfm-yaml-front-matter">YFM: YAML Front Matter</h4>
<div class="paragraph">
<p>The first thing we see in a
Jekyll file is the YAML Front Matter (YFM):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">---
layout: post
title:  "Welcome to Jekyll!"
date:   2014-03-03 12:56:40
categories: jekyll update
---</code></pre>
</div>
</div>
<div class="paragraph">
<p>YFM is a snippet of YAML ("YAML Aint Markup Language")
delimited by three hyphens on both the top and bottom. YAML is a simple structured
data serialization language used by many open source projects instead
of XML. Many people find it more readable and editable by humans
than XML. The YFM in this file shows a few configuration options: a
layout, the title, the date, and a list of categories.</p>
</div>
<div class="paragraph">
<p>The layout specified references one of the files in our <em>_layouts</em>
directory. If you don&#8217;t specify a layout file in the YFM, then Jekyll
assumes you want to use a file called <em>default.html</em> to wrap your
content. You can easily imagine adding your own custom layout files
to this directory and then overriding them in the YFM. If you look at
this file, you see that it manually specifies the <code>post</code> layout.</p>
</div>
<div class="paragraph">
<p>The title is used to generate the <code>&lt;title&gt;</code> tag and can be used
anywhere else you need it inside your template using the double-braces syntax from Liquid Markup: <code>{{ page.title }}</code>. Notice that any
variable from the <em>_config.yml</em> file is prefixed with the <code>site.</code>
namespace, while variables from your YFM are prefixed with <code>page.</code>
Though the title matches the filename (after replacing
spaces with hyphens), changing the title in the YFM does not affect
the name of the URL generated by Jekyll. If you want to change the URL, you need to
rename the file itself. This is a nice benefit if you need to slightly modify the
title and don&#8217;t want to damage preexisting URLs.</p>
</div>
<div class="paragraph">
<p>The date and categories are two other variables included in the YFM.
They are completely optional and strangely unused by the structure and
templates created by default using the Jekyll initializer. They do
provide additional context to the post, but are only stored in the
Markdown file and not included inside the generated content itself.
The categories list is often used to generate an index file of
categories with a list of each post included in a category. If you
come from a Wordpress background, you&#8217;ll likely have used categories.
These are generated dynamically from the MySQL database each time you
request a list of them, but in Jekyll this file is statically generated.
If you wanted something more dynamic, you could imagine generating a
JSON file with these categories and files, and then building a
JavaScript widget that requests this file and then does something
more interactive on the client side. Jekyll can take any template file
and convert it to JSON (or any other format)&#x2014;you are not limited to
just generating HTML files.</p>
</div>
<div class="paragraph">
<p>YFM is completely optional. A post or page can be rendered into your
Jekyll site without any YFM inside it. Without YFM, your page is
rendered using the defaults for those variables, so make sure the
default template, at the very least, is what you expect will wrap
around all pages left with unspecified layouts.</p>
</div>
<div class="paragraph">
<p>One important default variable for YFM is the published variable. This
variable is set to true by default. This means that if you create a
file in your Jekyll repository and do not manually specify the
published setting, it will be published automatically. If you set the
variable to false, the post will not be published. With
private repositories you can keep the contents of draft posts entirely
private until writing has completed by making sure published is set
to false. Unfortunately, not all tools that help you create Jekyll
Markdown files remember to set the published variable explicitly
inside of YFM, so make sure you check before committing the file to
your repository if there is something you don&#8217;t yet want published.</p>
</div>
</div>
<div class="sect3">
<h4 id="jekyll-markup">Jekyll Markup</h4>
<div class="paragraph">
<p>Going past the YFM, we can start to see the structure of
Markdown files. Markdown files can be, at their simplest, just textual
information without any formatting characters. In fact, if your layout files are
well done, you can definitely create great blog posts without any
fancy formatting, just pure textual content.</p>
</div>
<div class="paragraph">
<p>But with a few small Markdown additions, you can really make posts
shine. One of the first Markdown components we notice is the backtick
character, which is used to wrap small spans of code (or code-ish
information, like filenames in this case). As you use more and more
Markdown, you&#8217;ll find Markdown to be insidiously clever in the way it
provides formatting characters without the onerous weight that HTML
requires to offer the same explicit formatting.</p>
</div>
<div class="paragraph">
<p>Links can be specified using <code>[format][link]</code>, where <code>link</code> is the
fully qualified URL (like "<em><a href="http://example.com" class="bare">http://example.com</a></em>"), or a reference to a
link at the bottom of the page. In our page we have two references,
keyed as <code>jekyll-gh</code> and <code>jekyll</code>; we can then use these inside our
page with syntax like <code>[Jekyll&#8217;s GitHub repo][jekyll-gh]</code>. Using
references has an additional benefit in that you can use the link more
than once by its short name.</p>
</div>
<div class="paragraph">
<p>Though not offered in the sample, Markdown provides an easy way to
generate headers of varying degrees. To add a header, use the <code><mark></code>
character, and repeat the <code></mark></code> character to build smaller headers.
These delimiters simply map to the H tag; two hash characters (<code><mark></code>)
turns into an <code>&lt;h2&gt;</code> tag. Building text enclosed by <code>&lt;h3&gt;</code> tags looks
like <code></mark># Some Text</code>. You can optionally match the same number of hash
symbols at the end of the line if you find it more expressive (<code><mark>#
Some Text </mark>#</code>), but you don&#8217;t have to.</p>
</div>
<div class="paragraph">
<p>Markdown offers easy shortcuts for most HTML elements: numbered and
unordered lists, emphasis, and more. And, if you cannot find a
Markdown equivalent, you can embed normal HTML right next to
Markdown formatting characters. The best way to write Markdown is to
keep a
<a href="https://github.com/adam-p/Markdown-here/wiki/Markdown-Cheatsheet">Markdown
cheat sheet</a> near you when writing. <a href="http://daringfireball.net">John Gruber from Daring
Fireball</a> invented Markdown, and his site has a more in-depth
description of the how and why of Markdown.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-the-jekyll-command">Using the Jekyll Command</h4>
<div class="paragraph">
<p>Running <code>jekyll --help</code> will show you the options for running Jekyll.
You already saw the <code>jekyll serve</code> command, which builds the files into
the <em>_site</em> directory and then starts a web server with its root at that directory.
If you start to use this mechanism to build your Jekyll sites then
there are a few other switches you&#8217;ll want to learn about.</p>
</div>
<div class="paragraph">
<p>If you are authoring and adjusting a page often, and switching back
into your browser to see what it looks like, you&#8217;ll find utility in
the <code>-w</code> switch ("watch"). This can be used to automatically
regenerate the entire site if you make changes to any of the source
files. If you edit a post file and save it, that file will be
regenerated automatically. Without the <code>-w</code> switch you would need to
kill the Jekyll server, and then restart it.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
The Jekyll watch switch does reload all HTML and markup files, but
does not reload the <em>_config.yml</em> file. If you make changes to it, you
will need to stop and restart the server.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you are running multiple Jekyll sites on the same laptop, you&#8217;ll
quickly find that the second instance of <code>jekyll serve</code> fails because
it cannot open port 4000. In this case, use <code>jekyll --port 4010</code> to
open port 4010 (or whatever port you wish to use instead).</p>
</div>
</div>
<div class="sect3">
<h4 id="privacy-levels-with-jekyll">Privacy Levels with Jekyll</h4>
<div class="paragraph">
<p>Jekyll repositories on GitHub can be either public or private
repositories. If your repository is public you can host public content
generated from the Jekyll source files without publishing the source
files themselves. Remember, as noted previously, that any file without
<code>publishing: false</code> inside the YFM will be made public the moment you
push it into your repository.</p>
</div>
</div>
<div class="sect3">
<h4 id="themes">Themes</h4>
<div class="paragraph">
<p>Jekyll does not support theming internally, but it is trivial to add
any CSS files or entire CSS frameworks. You can also fork an existing
Jekyll blog that has the theming you like. We will show how and where
to add your own customized CSS later in the chapter.</p>
</div>
</div>
<div class="sect3">
<h4 id="publishing-on-github">Publishing on GitHub</h4>
<div class="paragraph">
<p>Once you have your blog created, you can easily publish it to GitHub.
There are two ways you can publish Jekyll blogs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>As a github.io site</p>
</li>
<li>
<p>On a domain you own</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>GitHub offers free personal blogs that are hosted on the github.io
domain. And you can host any site with your own domain name with a
little bit of configuration.</p>
</div>
<div class="sect4">
<h5 id="using-a-github-io-jekyll-blog">Using a GitHub.io Jekyll blog</h5>
<div class="paragraph">
<p>To create a github.io personal blog site, your Jekyll blog should be
on the master branch of your Git repository. The repository should be
named <code>username.github.io</code> on GitHub. If everything is set up correctly
you can then publish your Jekyll blog by adding a remote for GitHub
and pushing your files up. If you use the <code>hub</code> tool (a command for
interacting with Git and GitHub), you can go from start to finish with
a few simple commands. Make sure to change the first line to reflect
your username.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The hub tool was originally written in Ruby and as such could be
easily installed using only <code>gem install hub</code>, but hub was recently
rewritten in Go. Go has a somewhat more complicated installation
process, so we won&#8217;t document it here. If you have the <code>brew</code> command
installed for OS X, you can install hub with the <code>brew install hub</code>
command. Other platforms vary, so check <a href="http://github.com/github/hub" class="bare">http://github.com/github/hub</a>
to determine the best way for your system.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Use these commands to install your github.io hosted Jekyll blog:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ export USERNAME=xrd
$ jekyll new $USERNAME.github.io
$ cd $USERNAME.github.io
$ git init
$ git commit -m "Initial checkin" -a
$ hub create  # You'll need to login here...
$ sleep $((10*60)) &amp;&amp; open $USERNAME.github.io</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second to the last line creates a repository on GitHub for you
with the same name as the directory. That last line sleeps for 10
minutes while your github.io site is provisioned on GitHub, and then
opens the site in your browser for you. It can take ten minutes for
GitHub to configure your site the first time, but subsequent content
pushes will be reflected immediately.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="hosting-on-your-own-domain">Hosting On Your Own Domain</h4>
<div class="paragraph">
<p>To host a blog on your own domain name, you need to use the <code>gh-pages</code>
branch inside your repository. You need to create a CNAME file in your
repository, and then finally establish DNS settings to point your domain to
the GitHub servers.</p>
</div>
<div class="sect4">
<h5 id="the-gh-pages-branch">The gh-pages branch</h5>
<div class="paragraph">
<p>To work on the gh-pages branch, check it out and create the branch
inside your repository:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ git checkout -b gh-pages
$ rake post title="My next big blog post"
$ git add _posts
$ git commit -m "Added my next big blog post"
$ git push -u origin gh-pages</code></pre>
</div>
</div>
<div class="paragraph">
<p>You will need to always remember to work on the gh-pages branch; if
this repository is only used as a blog, then this probably is not an
issue. Adding the <code>-u</code> switch will make sure that Git always pushes up
the gh-pages branch whenever you do a push.</p>
</div>
</div>
<div class="sect4">
<h5 id="the-cname-file">The CNAME file</h5>
<div class="paragraph">
<p>The CNAME file is a simple text file with the domain name inside of it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ echo 'mydomain.com' &gt; CNAME
$ git add CNAME
$ git commit -m "Added CNAME"
$ git push</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once you have pushed the CNAME file to your repository, you can verify
that GitHub thinks the blog is established correctly by visiting the
admin page of your repository. An easy way to get there is using the
<code>github</code> gem, which is no longer actively maintained but is still a useful command-line tool:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ gem install github
$ github admin # Opens up https://github.com/username/repo/settings</code></pre>
</div>
</div>
<div class="paragraph">
<p>The github gem is a useful command-line tool, but unfortunately it is
tied to an older version of the GitHub API, which means the documented
functionality is often incorrect.</p>
</div>
<div class="paragraph">
<p>If your blog is correctly set up, you will see something like <a href="#settings-jekyll-blog">Settings for a Jekyll blog</a> in the middle of your settings page.</p>
</div>
<div id="settings-jekyll-blog" class="imageblock">
<div class="content">
<img src="images/btwg_0603.png" alt="btwg 0603">
</div>
<div class="title">Figure 3. Settings for a Jekyll blog</div>
</div>
<div class="paragraph">
<p>GitHub has properly recognized the CNAME file and will accept requests
made to that host on its servers. We are still not yet complete,
however, in that we need to make sure the DNS is established for our site.</p>
</div>
</div>
<div class="sect4">
<h5 id="dns-settings">DNS settings</h5>
<div class="paragraph">
<p>Generally, establishing DNS settings for your site is straightforward.
It is easiest if you are setting up DNS with a <em>subdomain</em> as opposed
to an <em>apex domain</em>. To be more concrete, an apex domain is a site
like <em>mypersonaldomain.com</em>, while a subdomain would be
<em>blog.mypersonaldomain.com</em>.</p>
</div>
<div class="paragraph">
<p>Setting up a blog on a subdomain is simple: create a CNAME record in DNS that points
to <em>username.github.io</em>.</p>
</div>
<div class="paragraph">
<p>For an apex domain, things are slightly more complicated. You must create DNS
A records to point to these IP addresses: <code>192.30.252.153</code> and
<code>192.30.252.154</code>.  These are the IP addresses right now; there is
always the possibility that GitHub could change these at some point in
the future. For this reason, hosting on apex domains is risky. If
GitHub needed to change its IP addresses (say during a denial-of-service attack), you would need to respond to this, and deal with the
DNS propagation issues. If you instead use a subdomain, the CNAME
record will automatically redirect to the correct IP even if it is
changed by GitHub.<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="importing-from-other-blogs">Importing from Other Blogs</h3>
<div class="paragraph">
<p>There are many tools that can be used to import an existing blog into
Jekyll. As Jekyll is really nothing more than a file-layout
convention, you just need to pull the relevant pieces (the post
itself, and associated metadata like the post title, publishing date,
etc.) and then write out a file with those contents. Jekyll blogs
prefer Markdown, but they work fine with HTML content, so you can
often convert a blog with minimal effort, and there are good tools
that automate things for you.</p>
</div>
<div class="sect3">
<h4 id="from-wordpress">From Wordpress</h4>
<div class="paragraph">
<p>The most popular importer is the Wordpress importer. You will need the
'jekyll-import' gem. This gem is distributed separately from the core
Jekyll gem, but will be installed if you use the <code>github-pages</code> gem
inside your Gemfile and use the <code>bundle</code> command.</p>
</div>
<div class="sect4">
<h5 id="importing-with-direct-database-access">Importing with direct database access</h5>
<div class="paragraph">
<p>Once you have the <code>jekyll-import</code> gem, you can convert a Wordpress
blog using a command like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ ruby -rubygems -e 'require "jekyll-import";
    JekyllImport::Importers::WordPress.run({
      "dbname"   =&gt; "wordpress",
      "user"     =&gt; "hastie",
      "password" =&gt; "lanyon",
      "host"     =&gt; "localhost",
      "status"         =&gt; ["publish"]
    })'</code></pre>
</div>
</div>
<div class="paragraph">
<p>This command will import from an existing Wordpress installation,
provided that your Ruby code can access your database. This will work if you can
log in to the server itself and run the command on the server, or if
the database is accessible across the network (which is generally bad
practice when hosting Wordpress!).</p>
</div>
<div class="paragraph">
<p>Note the status option: this specifies that imported pages and posts
are published automatically. More specifically, the YAML for each file
will specify <code>published: true</code>, which will publish the page or post
into your blog. If you want to review each item individually, you can
specify a status of <code>private</code>, which will export the pages into Jekyll
but leave them unpublished. Remember that if your repository is
public, posts marked as unpublished will not be displayed in the blog but
can still be seen if someone visits your the repository for your blog
on GitHub.</p>
</div>
<div class="paragraph">
<p>There are many more options than listed here. For example, by default,
the Wordpress-Jekyll importer imports categories from your Wordpress
database, but you can turn this off by specifying <code>"categories" &#8658;
false</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="importing-from-the-wordpress-xml">Importing from the Wordpress XML</h5>
<div class="paragraph">
<p>Another alternative is to export the entire database as an XML file.
Then, you can run the importer on that file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">ruby -rubygems -e 'require "jekyll-import";
    JekyllImport::Importers::WordpressDotCom.run({
      "source" =&gt; "wordpress.xml",
      "no_fetch_images" =&gt; false,
      "assets_folder" =&gt; "assets"
    })'</code></pre>
</div>
</div>
<div class="paragraph">
<p>This can be used to export files from a server you don&#8217;t
maintain, but works with sites you do maintain and might be a more
plausible option than running against a database.</p>
</div>
<div class="paragraph">
<p>To export the XML file, visit the export page on your Wordpress
site. This is usually mapped to <em>/wp-admin/export.php</em>, so it will be
something like <em><a href="https://blogname.com/wp-admin/export.php" class="bare">https://blogname.com/wp-admin/export.php</a></em> (replacing
&#x201c;blogname.com&#x201d; with your blog&#8217;s name).</p>
</div>
<div class="paragraph">
<p>Like many free tools, there are definitely limitations to using this
method of export. If your Wordpress site is anything beyond the
simplest of Wordpress sites, then using this tool to import from
Wordpress means you will lose much of the metadata stored inside your
blog. This metadata can include pages, tags, custom fields, and image
attachments.</p>
</div>
<div class="paragraph">
<p>If you want to keep this metadata, then you might
consider another import option like Exitwp. Exitwp is a Python tool
that provides a much higher level of fidelity between the original
Wordpress site and the final Jekyll site, but has a longer learning
curve and option set.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="exporting-from-wordpress-alternatives">Exporting from Wordpress Alternatives</h4>
<div class="paragraph">
<p>If you use another blog format other than Wordpress, chances are there
is a Jekyll importer for it. Jekyll has dozens of importers, well
documented on the <a href="http://import.jekyllrb.com">Jekyll importer site</a>.</p>
</div>
<div class="paragraph">
<p>For example, this command-line example from the importer site exports
from Tumblr blogs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">$ ruby -rubygems -e 'require "jekyll-import";
    JekyllImport::Importers::Tumblr.run({
      "url"            =&gt; "http://myblog.tumblr.com",
      "format"         =&gt; "html", # <b class="conum">(1)</b>
      "grab_images"    =&gt; false,  # <b class="conum">(2)</b>
      "add_highlights" =&gt; false,  # <b class="conum">(3)</b>
      "rewrite_urls"   =&gt; false   # <b class="conum">(4)</b>
    })'</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Tumblr import plug-in has a few interesting options.</p>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Write out HTML; if you prefer to use Markdown use <code>md</code>.</p>
</li>
<li>
<p>This importer will grab images if you provide a true value.</p>
</li>
<li>
<p>Wrap code blocks (indented four spaces) in a Liquid Markup "highlight" tag
if this is set to true.</p>
</li>
<li>
<p>Write pages that redirect from the old Tumblr paths to the new
Jekyll paths using this configuration option.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Exporting from Tumblr is considerably easier than Wordpress. The
Tumblr exporter scrapes all public posts from the blog, and then
converts to a Jekyll-compatible post format.</p>
</div>
<div class="paragraph">
<p>We&#8217;ve seen how we can use the importers available on
<a href="http://import.jekyllrb.com"><em>import.jekyllrb.com</em></a> to import. What if we have a nonstandard site
we need to import?</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scraping-sites-into-jekyll">Scraping Sites into Jekyll</h3>
<div class="paragraph">
<p>Jekyll provides various importers that make it easy to convert an
existing blog into a Jekyll blog. But if you have a nonstandard
blog, or a site that is not a blog, you still have options for
migrating it to Jekyll. The first option is to write your own importer
by perusing the <a href="http://github.com/jekyll/jekyll-import">source of the
Jekyll importers on GitHub</a>. This is probably the right way to
build an importer if you plan on letting others use it, as it will
extend several Jekyll importer classes already available to make
importing standard for other contributors.</p>
</div>
<div class="paragraph">
<p>Another option is to simply write out files in the simple format that
is a Jekyll blog. This is much lazier than reading through the Jekyll
tools and their libraries, of course. I started as a Perl programmer and
always loved this quote from Larry Wall, the creator of Perl: "We will
encourage you to develop the three great virtues of a programmer:
laziness, impatience, and hubris." Let&#8217;s accept our inherent laziness
and choose the second route. We&#8217;ll write some code to scrape a site
and make a new Jekyll site from scratch, learning about the structure
of a Jekyll blog through trial and error.</p>
</div>
<div class="paragraph">
<p>While living in Brazil in 2000 I built a site called ByTravelers.com,
an early travel blog. At some point, I sadly lost the database and
thought the site contents were completely gone. Almost by accident, I
happened upon ByTravelers on Archive.org, the Internet Archive. I
found that almost all of the articles were listed there and
available. Though the actual database is long gone, could we recover
the data from the site using Archive.org?</p>
</div>
<div class="sect3">
<h4 id="jekyll-scraping-tactics">Jekyll Scraping Tactics</h4>
<div class="paragraph">
<p>We can start by looking at the structure of the archive presented on
Archive.org. Go to Archive.org, enter "bytravelers.com" into the
search box in the middle of the page, and then click "BROWSE HISTORY."
You will see a calendar view that shows all the pages
scraped by the Internet Archive for this site as shown in <a href="#calendar-view-archive">Calendar view of Archive.org</a>.</p>
</div>
<div id="calendar-view-archive" class="imageblock">
<div class="content">
<img src="images/btwg_0604.png" alt="btwg 0604">
</div>
<div class="title">Figure 4. Calendar view of Archive.org</div>
</div>
<div class="paragraph">
<p>In the middle of 2003 I took down the server, intending to
upgrade it to another set of technologies, and never got around to
completing this migration, and then lost the data. If we click the
calendar item on June 6th, 2003, we will see a view of the data that
was more or less complete at the height of the site&#8217;s functionality
and data. There are a few broken links to images, but otherwise the
site is functionally archived inside Archive.org (<a href="#calendar-view-bytravelers">Archive of ByTravelers.com on Archive.org</a>).</p>
</div>
<div id="calendar-view-bytravelers" class="imageblock">
<div class="content">
<img src="images/btwg_0605.png" alt="btwg 0605">
</div>
<div class="title">Figure 5. Archive of ByTravelers.com on Archive.org</div>
</div>
<div class="paragraph">
<p>Taking the URL from our browser, we can use this as our starting point for
scraping. Clicking around throughout the site, it becomes evident that
each URL to a journal entry uses a standard format; in other words,
<em><a href="http://www.bytravelers.com/journal/entry/56" class="bare">http://www.bytravelers.com/journal/entry/56</a></em> indicates the 56th
journal item stored on the site. With this knowledge in hand, we can
iterate over the first hundred or so URLs easily.</p>
</div>
</div>
<div class="sect3">
<h4 id="setting-up">Setting Up</h4>
<div class="paragraph">
<p>A naive implementation of a scraper would be a single Ruby file in
which the execution and functionality were contained all in one.
However, if we expose the functionality as a class, and then
instantiate the class in a separate file, we can also write tests
that utilize and validate the same steps as the runner script. So,
let&#8217;s take this smarter approach and create three files: the scraper
class, the runner class (which instantiates and "runs" our scraper), and the test
file (which instantiates and validates the functionality of our scraper).</p>
</div>
<div class="paragraph">
<p>First, the runner script:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#!/usr/bin/env ruby

require './scraper'

scraper = Scraper.new()
scraper.run()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our barebones scraper class just looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">class Scraper
  def run

  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>We also need to have a manifest file, the Gemfile, where we will
document our library dependencies:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">source "https://rubygems.org"

gem "github-pages"
gem "rspec"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, install our gems using the command <code>bundle</code>. That installs the
rspec tool, the Jekyll tool, and associated libraries.</p>
</div>
<div class="paragraph">
<p>Finally, we can create our test harness:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">require './scraper'

describe "#run" do
  it "should run" do
    scraper = Scraper.new
    scraper.run()
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Remember to run using the <code>bundle exec rspec scraper_spec.rb</code> command,
which makes everything run inside the bundler context (and load our
libraries from the Gemfile, instead of the default system gems):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ bundle exec rspec scraper_spec.rb
.

Finished in 0.00125 seconds (files took 0.12399 seconds to load)
1 example, 0 failures</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is nothing we are explicitly testing yet, but
our test harness displays that our code inside our tests will match
closely the code we write inside our runner wrapper.</p>
</div>
</div>
<div class="sect3">
<h4 id="scraping-titles">Scraping Titles</h4>
<div class="paragraph">
<p>Let&#8217;s start with something simple: scraping the titles from the
site. We&#8217;ll use Ruby to scrape the site; Ruby has some intuitive gems like
mechanize that simplify building web clients. There is an API for
the Internet archive, but I found it flakey and unreliable, so we&#8217;ll
just scrape the site. Add these additional lines to the Gemfile using
this command and then install the libraries:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ echo "gem 'mechanize'" &gt;&gt; Gemfile
$ bundle</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can modify our scraper to use the mechanize gem and retrieve content from Archive.org:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">require 'mechanize' # # <b class="conum">(1)</b>

class Scraper

  attr_accessor :root # # <b class="conum">(2)</b>
  attr_accessor :agent

  def initialize # # <b class="conum">(3)</b>
    @root = "http://web.archive.org/web/20030820233527/" +
    "http://bytravelers.com/journal/entry/" # # <b class="conum">(4)</b>
    @agent = Mechanize.new
  end

  def run
    100.times do |i| # # <b class="conum">(5)</b>
      url = "#{@root}#{i}" # # <b class="conum">(6)</b>
      @agent.get( url ) do |page|
        puts "#{i} #{page.title}"
      end
    end
  end

end</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Require the mechanize library.</p>
</li>
<li>
<p>We use a Ruby method called <code>attr_accessor</code>, which creates a public
instance variable. We can use variables created using <code>attr_accessor</code>
by prefixing the variable name with an <code>@</code> character. Instance
variables are accessible outside the class as well.</p>
</li>
<li>
<p>When a method named <code>initialize</code> is defined for a class, this
method is called right after object creation, so this is the appropriate
place for us to initialize the member variables.</p>
</li>
<li>
<p>Initialize the variables to default values. We store the root of
the URL to the cached copy of ByTravelers.com here.</p>
</li>
<li>
<p>Our run method runs the block inside 100 times.</p>
</li>
<li>
<p>Our block starts by generating a URL to the specific page,
retrieves the page, and then prints out the index in our loop plus the
title of the page object.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Let&#8217;s run our scraper and see what happens now:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ bundle exec ./run.rb
...
53 Read Journal Entries
54 Read Journal Entries
55 Read Journal Entries
56 Read Journal Entries
57 Internet Archive Wayback Machine
58 Internet Archive Wayback Machine
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see that some of the entries have a generic "Internet Archive
Wayback Machine" while some have "Read Journal Entries." Archive.org
will respond with a placeholder title when it does not have content
from the site (as is the case with item #58, for example). We should
ignore those pages that don&#8217;t have the string "Read Journal Entries"
as the title (which tells us Archive.org does have cached content from
our site).</p>
</div>
<div class="paragraph">
<p>Now that we have all the content, we can start finding the important
pieces inside and putting them into our Jekyll posts.</p>
</div>
</div>
<div class="sect3">
<h4 id="refinining-with-interactive-ruby">Refinining with Interactive Ruby</h4>
<div class="paragraph">
<p>There are two things that make Mechanize immensely powerful as the
foundation for a scraping tool: easy access to making HTTP calls, and
a powerful searching syntax once you have a remote document. You&#8217;ve
seen how Mechanize makes it simple to make a GET request. Let&#8217;s
explore sifting through a massive document to get the important pieces
of textual content. We can manually explore scraping using the Ruby
IRB (interactive Ruby shell):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">$ irb -r./scraper
2.0.0-p481 :001 &gt; scraper = Scraper.new
 =&gt; #&lt;Scraper:0x00000001e37ca8...&gt;
2.0.0-p481 :002 &gt; page = scraper.agent.get "#{scraper.root}#{56}"
 =&gt; #&lt;Mechanize::Page {url #&lt;URI::HTTP:0x00000001a85218...&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first line invokes IRB and uses the <code>-r</code> switch to load the
scraper library in the current directory. If you have not used IRB
before, there are a few things to know that
will make life easier. The IRB has a prompt, which indicates the
version of Ruby you are using, and the index of the command you are
running. IRB has a lot of features beyond what we will discuss here,
but those indexes can be used to replay history and for job control,
like many other types of shells. At the IRB prompt you can enter Ruby
and IRB executes the command immediately. Once the command executes,
IRB prints the result; the characters <code>&#8658;</code> indicate the return
value. When you are playing with Ruby, return values will often be complex
objects: the return value when
you use <code>scraper.agent.get</code> is a Mechanize Ruby object. This is a very
large object, so printing it out takes a lot of real estate. We&#8217;ve
abbreviated the majority of it here, and will do that for many complex
objects to save space when discussing IRB.</p>
</div>
<div class="paragraph">
<p>The last command in IRB saves the HTTP GET request as a page object.
Once we have the page, how do we extract information from it?
Mechanize has a nice piece of syntactic sugar that makes it easy to
search the DOM structure: the "/" operator. Let&#8217;s try it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">2.0.0-p481 :003 &gt; page / "tr"
 =&gt; []</code></pre>
</div>
</div>
<div class="paragraph">
<p>If our query path had found anything, we would have seen a return
value with an array of Mechanize objects, but in this case we got back an
empty array (which indicates nothing was found). Unfortunately, the
paths vary when the document is loaded into a browser (the browser can
customize the DOM or the server can send slightly different data to
the client). But if we experiment with similar paths inside IRB, we
will find what we need. It helps to jump back and forth between Chrome
and IRB, examining the structure of the HTML inside Chrome and then
testing a search path using IRB. Eventually, we come across this search path:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">2.0.0-p481 :004 &gt; items = page /  "table[valign=top] tr"
 =&gt; [#&lt;Nokogiri::XML::Element:0xc05670 name="font"
      attributes=[#&lt;Nokogiri::XML::Attr:0xc05328 name="size"
      value="-2"&gt;]...
2.0.0-p481 :005 &gt; items.length
 =&gt; 5
2.0.0-p481 :006 &gt; items[0].text()
 =&gt; "\n\n\n\n\n\n\n\n\n\nBeautiful Belize\n\n\n\n\n\n\n"
2.0.0-p481 :005 &gt; items[0].text().strip
 =&gt; "Beautiful Belize"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Eureka, we found the pattern that gives us our title. We had to jump
around inside the results from the query, but we can correlate the
text on the page inside the browser with different structures found
using the query inside IRB. It is important to note that we have to
strip whitespace from the title to make it presentable. We can
incorporate this into our scraper code, but this is a good moment to
think about how we can write tests to verify this works properly. And
when we start writing tests, we open the door for another opportunity:
caching to our HTTP requests.</p>
</div>
</div>
<div class="sect3">
<h4 id="writing-tests-and-caching">Writing Tests and Caching</h4>
<div class="paragraph">
<p>Were we to run our <code>run.rb</code> script again, we would notice that it
prints the document title, then halts as it retrieves the content from
the server, and then prints again, stopping and starting until
complete. The content from Archive.org does not change at all since
the original site was
scraped years ago, so there is no reason we need to get the latest
content; content even several months stale will be the same as content
retrieved a few moments ago. It seems like a good opportunity to put a
caching layer between us and the code, reducing impact on Archive.org
and making our script run faster. In addition, if we structure our
code to make retrieval and processing happen independently, we can
write tests to verify the processing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">require 'mechanize'
require 'vcr' # # <b class="conum">(1)</b>
VCR.configure do |c| # # <b class="conum">(2)</b>
  c.cassette_library_dir = 'cached'
  c.hook_into :webmock
end

class Scraper

  attr_accessor :root
  attr_accessor :agent
  attr_accessor :pages # # <b class="conum">(3)</b>

  def initialize
    @root = "http://web.archive.org/web/20030820233527/" +
    "http://bytravelers.com/journal/entry/"
    @agent = Mechanize.new
    @pages = [] # # <b class="conum">(4)</b>
  end

  def scrape
    100.times do |i|
      begin
        VCR.use_cassette("bt_#{i}") do # # <b class="conum">(5)</b>
          url = "#{@root}#{i}"
          @agent.get( url ) do |page|
            if page.title.eql? "Read Journal Entries" # # <b class="conum">(6)</b>
              pages &lt;&lt; page
            end
          end
        end
      rescue Exception =&gt; e
        STDERR.puts "Unable to scrape this file (#{i})"
      end
    end
  end

  def process_title( row )
    row.strip # # <b class="conum">(7)</b>
  end

  def run
    scrape()
    @pages.each do |page| # # <b class="conum">(8)</b>
      rows = ( page / "table[valign=top] tr" )
      puts process_title( rows[0].text() )
    end
  end

end</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We require the VCR gem: this gem intercepts HTTP requests, sending
them out normally the first time, and caching all successive calls,
completely transparent to the user.</p>
</li>
<li>
<p>VCR must be configured when you use it: in this case we specify a
directory where results will be cached, and tell it what mocking
library we should use to store the cached results.</p>
</li>
<li>
<p>We establish a new variable called pages. We will scrape all the
pages into this array (and get them for free once the information is
cached).</p>
</li>
<li>
<p>Initialize the pages array here.</p>
</li>
<li>
<p>To use the VCR recording feature, we wrap any code that makes
HTTP requests inside a VCR block with a name specifying the cassette
to save it under. In this case, we use a cassette named bt (for
ByTravelers) with the index of the page. The first time we use the
scraper to request the page, it is retrieved and stored inside the
cache. Successive calls to the scraper <code>get</code> method are retrieved from
the cached responses.</p>
</li>
<li>
<p>We then look for any titles that look like pages archived into
Archive.org (using the title to differentiate) and if we find one,
store that page into our pages array for later processing.</p>
</li>
<li>
<p>We move the title processing into its own method called
<code>process_title</code>. Here we use the information and remove any
whitespace.</p>
</li>
<li>
<p>Inside of <code>run</code> we now call <code>scrape</code> to load the pages, and then
iterate over each page, searching inside them and processing the titles.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We need to install the VCR and webmock libraries, so add them to the
Gemfile:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ echo "gem 'vcr'" &gt;&gt; Gemfile
$ echo "gem 'webmock'" &gt;&gt; Gemfile
$ bundle</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we run our script using <code>bundle exec ruby ./run.rb</code>, we will see it
print out the titles:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ bundle exec ruby ./run.rb
Unable to scrape this file (14)
Unable to scrape this file (43)
Unable to scrape this file (47)
Unable to scrape this file (71)
Unable to scrape this file (94)
Unable to scrape this file (96)
Third day in Salvador
The Hill-Tribes of Northern Thailand
Passion Play of Oberammergau
"Angrezis in Bharat"
Cuba - the good and bad
Nemaste
Mexico/Belize/Guatemala
South Africa
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>We print out the errors (when Archive.org does not have a page for a
particular URL). Note that as a side effect of caching, things work
much faster. If we analyze the time we save using the <code>time</code> command,
we see these results:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ time bundle exec ruby ./run.rb # before VCR
real    0m29.907s
user    0m2.220s
sys     0m0.170s
$ time bundle exec ruby ./run.rb # after VCR
real    0m3.750s
user    0m3.474s
sys     0m0.194s</code></pre>
</div>
</div>
<div class="paragraph">
<p>So, it takes an order of magnitude more time without caching. And, we
get these cached responses for free, and inside our IRB sessions as well.</p>
</div>
<div class="paragraph">
<p>The titles look good, but the fourth one is a little worrisome. Looks
like one of the users decided to enclose their title in double
quotes. To control the formatting, it would be nice to clean that
up. Let&#8217;s do that, and write tests to verify things work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">require './scraper'

describe "#run" do
  before :each  do
    @scraper = Scraper.new
  end

  describe "#process_titles" do
    it "should correct titles with double quotes" do
      str = ' something " with a double quote'
      expect( @scraper.process_title( str ) ).to_not match( /"/ )
    end

    it "should strip whitespace from titles" do
      str = '\n\n something between newlines \n\n'
      expect( @scraper.process_title( str ) ).to_not match( /^\n\n/ )
    end
  end

end</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we run this, we see one test pass and one test fail:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ bundle exec rspec scraper_spec.rb
F.

Failures:

  1) #run #process_titles should correct titles with double quotes
     Failure/Error: expect( @scraper.process_title( ' something " with
     a double quote' ) ).to_not match( /"/ )
       expected "something \" with a double quote" not to match /"/
       Diff:
       @@ -1,2 +1,2 @@
       -/"/
       +"something \" with a double quote"
     # ./scraper_spec.rb:10:in `block (3 levels) in &lt;top (required)&gt;'

Finished in 0.01359 seconds (files took 0.83765 seconds to load)
2 examples, 1 failure

Failed examples:

rspec ./scraper_spec.rb:9 # #run #process_titles should correct titles
with double quotes</code></pre>
</div>
</div>
<div class="paragraph">
<p>To fix this test, let&#8217;s strip out the double quotes by changing one line
in the <em>scraper.rb</em> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">...

def process_title( row )
  row.strip.gsub( /"/, '' )
end

...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now both tests pass. That line of code might be worrisome if
you believe in defensive coding. If this function were called with a
nil value, for example, it would crash. Even if we could guarantee
that this situation would never occur from our calling context, it is
better to make our method safe. Let&#8217;s make sure it works and write a
test to prove it.</p>
</div>
<div class="paragraph">
<p>Add a test that asserts there is not an error when the argument to
<code>process_title</code> is nil:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">...
it "should not crash if the title is nil" do
  expect{ @scraper.process_title( nil ) }.to_not raise_error()
end
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Running <code>rspec scraper_spec.rb</code> results in the following error, which
we expect since we have not yet fixed the code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">..F..

Failures:

  1) #run #process_titles should not crash if the title is nil
     Failure/Error: expect{ @scraper.process_title( nil ) }.to_not raise_error()
       expected no Exception, got #&lt;NoMethodError: undefined method
     `strip' for nil:NilClass&gt; with backtrace:
         # ./scraper.rb:38:in `process_title'
         # ./scraper_spec.rb:20:in `block (4 levels) in &lt;top (required)&gt;'
         # ./scraper_spec.rb:20:in `block (3 levels) in &lt;top (required)&gt;'
     # ./scraper_spec.rb:20:in `block (3 levels) in &lt;top (required)&gt;'

Finished in 0.00701 seconds
5 examples, 1 failure

Failed examples:

rspec ./scraper_spec.rb:19 # #run #process_titles should not crash if the title
# is nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can fix it with this one simple change:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">...

def process_title( row )
  row.strip.gsub( /"/, '' ) if row
end
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we are in a position to write out the files for our actual posts.</p>
</div>
</div>
<div class="sect3">
<h4 id="writing-jekyll-posts">Writing Jekyll Posts</h4>
<div class="paragraph">
<p>With our titles in hand, we can generate an actual Jekyll
post. To keep things simple each post will contain nothing beyond the
titles for now, but we will quickly add other content. Getting the
skeleton of a post established allows us to use the Jekyll command-line
tools to troubleshoot our setup.</p>
</div>
<div class="paragraph">
<p>First, create a Git repository for our files. When the Jekyll tool
runs, it generates all the files into a directory called <em>_site</em> so we
should add a <em>.gitignore</em> file, which ignores this directory:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ git init
$ mkdir _posts
$ echo "_site" &gt;&gt; .gitignore
$ git add .gitignore
$ git commit -m "Initial checkin"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jekyll Markdown files are very simple: just a bit of YAML at the
beginning, with text content following, formatted as Markdown.  To
generate Markdown posts, add a method called <code>write</code> to our scraper
that writes out the processed information after we have retrieved and
parsed the pages from Archive.org.</p>
</div>
<div class="paragraph">
<p>Jekyll posts are stored inside the <em>_posts</em> directory. As a
convention, filenames are generated with the date and title,
lowercased, converted to a string without any characters beyond a-z
and the hyphen, and terminated by the extension (usually <em>.md</em> for
Markdown). In order to properly generate the filename, we will need to
scrape the date, so we will do that as well.</p>
</div>
<div class="paragraph">
<p>As a more concrete example, we want to take something like <code>Cuba - the
good and bad</code> that happened on January 12th, 2001, and make a filename
like <code>2001-01-12-cuba-the-good-and-bad.md</code>. Or,
<code>Mexico/Belize/Guatemala</code> from the same date, and make it into the
filename <code>2001-01-12-mexico-belize-guatemala.md</code>. These conversions
look like good places to write tests, so we can start there:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">describe "#get_filename" do
  it "should take 'Cuba - the good and bad' on January 12th, 2001" +
      " and get a proper filename" do
    input = 'Cuba - the good and bad'
    date = "January 12th, 2001"
    output = "2001-01-12-cuba-the-good-and-bad.md"
    expect( @scraper.get_filename( input, date ) ).to eq( output )
  end

  it "should `Mexico/Belize/Guatemala` and get a proper filename" do
    input = "Mexico/Belize/Guatemala"
    date = "2001-01-12"
    output = "2001-01-12-mexico-belize-guatemala.md"
    expect( @scraper.get_filename( input, date ) ).to eq( output )
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s build the <code>get_filename</code> method. This method uses the handy Ruby
<code>DateTime.parse</code> method to convert a string representation of a date
into a date object, and then uses the <code>strfmtime</code> method to format
that date into the format we want in our filename:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">...
def get_filename( title, date )
  processed_date = DateTime.parse( date )
  processed_title = title.downcase.gsub( /[^a-z]+/, '-' )
  "#{processed_date.strftime('%Y-%m-%d')}-#{processed_title}.md"
end
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we run our tests now, we will see them both pass.</p>
</div>
<div class="paragraph">
<p>Now we can add to our scraper so that it can write out the posts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def render( processed ) # # <b class="conum">(1)</b>
  processed['layout'] = 'post'
  rendered = "#{processed.to_yaml}---\n\n" # # <b class="conum">(2)</b>
  rendered
end

def write( rendered, processed ) # # <b class="conum">(3)</b>
  Dir.mkdir( "_posts" ) unless File.exists?( "_posts" )
  filename = get_filename( processed['title'], processed['creation_date'] )
  File.open( "_posts/#{filename}", "w+" ) do |f|
    f.write rendered
  end
end

def process_creation_date( date )
  tuple = date.split( /last updated on:/ ) # # <b class="conum">(4)</b>
  rv = tuple[1].strip if tuple and tuple.length &gt; 1
  rv
end

def run
  scrape()
  @pages.each do |page| # # <b class="conum">(5)</b>
    rows = ( page / "table[valign=top] tr" )
    processed = {}
    processed['title'] = process_title( rows[0].text() )
    processed['creation_date'] = process_creation_date( rows[3].text() ) # # <b class="conum">(6)</b>
    rendered = render( processed )
    write( rendered, processed )
  end</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We define a render method. This takes the processed information
(which arrives as a hash) and renders the information into the proper
format: the YAML Front Matter (YFM) and then the body (which we don&#8217;t
have yet). We then return the rendered string.</p>
</li>
<li>
<p>We use the <code>to_yaml</code> method on our hash. This method appears when
we include the yaml library using <code>require 'yaml'</code> (not displayed
here, but easy to add to the <em>scraper.rb</em> file and present in the
samples on GitHub).</p>
</li>
<li>
<p>The write method writes the rendered content to disk. It makes
sure the <em>_posts</em> directory is available, and if not, creates it. It
then writes out the file using our <code>get_filename</code> method to get the
path, prefixed with the <em>_posts</em> directory.</p>
</li>
<li>
<p><code>process_creation_date</code> takes a piece from the scraped page and
breaks it apart by the string &#x201c;<code>last updated</code> on:&#x201d; and uses the second
item in the resultant array.</p>
</li>
<li>
<p>Inside our run method we now build out the processed hash, finding
the date and title using rows from the query path we used before.</p>
</li>
<li>
<p>Once we have our processed array, we can "render" it and then
write out the rendered string to our filesystem.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If we generate the posts by calling <code>bundle exec ruby ./run.rb</code> we
will see our posts generated into the <em>_posts</em> directory. Choosing a
random one, they look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">---
title: Beautiful Belize
creation_date: '2003-03-23'
layout: post
---</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, for now, posts are nothing more than the YFM, but this
is still a perfectly valid Jekyll post.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s use the jekyll command-line tool to start looking at our
posts and to troubleshoot any issues with our Jekyll repository.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-the-jekyll-command-line-tool">Using the Jekyll Command-Line Tool</h4>
<div class="paragraph">
<p>Taking a moment to add our files to the Git repository, we can then
take a look at our site using the <code>jekyll</code> command-line tool. Using
the command-line tool locally will spot check our new content as we
will see errors immediately (rather than getting notification emails
from GitHub after publishing there). Errors can occur if our scraper
does not correctly process the HTML retrieved from Archive.org and
subsequently generates incorrect Markdown content, for example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ git add .
$ git commit -m "Make this into a Jekyll site"
...
$ jekyll serve --watch
Configuration file: none
            Source: /home/xrdawson/bytravelers
       Destination: /home/xrdawson/bytravelers/_site
      Generating...
     Build Warning: Layout 'post' requested in _posts/2000-05-23-third-day-in...
     Build Warning: Layout 'post' requested in _posts/2000-08-28-the-hill-tri...
     ...
                    done.
 Auto-regeneration: enabled for '/home/xrdawson/bytravelers'
Configuration file: none
    Server address: http://0.0.0.0:4000/
  Server running... press ctrl-c to stop.</code></pre>
</div>
</div>
<div class="paragraph">
<p>So, we see a few problems already. First, we don&#8217;t have a layout for
"post." And, there is no configuration file. Let&#8217;s fix these problems.</p>
</div>
<div class="paragraph">
<p>Add a file called <em>_config.yml</em> to the root directory:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">name: ByTravelers.com: Online travel information
markdown: redcarpet
highlighter: pygments</code></pre>
</div>
</div>
<div class="paragraph">
<p>Remember, the jekyll tool does not reload the configuration file
automatically, so we should restart the tool by hitting Ctrl-C and
restarting.</p>
</div>
<div class="paragraph">
<p>Then, create a directory called <em>_layouts</em>, and place a file called
<em>post.html</em> inside it with these contents:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">---
layout: default
---

&lt;h1&gt;{{ page.title }}&lt;/h1&gt;

{{ content }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>post.html</em> layout file is very simple: we use Liquid Markup tags
to write out the title of the site (contained in an object called
<code>page</code>, which our template has access to) and then the content itself,
which is the rendered output from the post page.</p>
</div>
<div class="paragraph">
<p>We also need to create a "default" layout, so create this inside the
<em>_layouts</em> directory with the filename <em>default.html</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;html&gt;
&lt;head&gt;
&lt;title&gt;ByTravelers.com&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;

{{ content }}

&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This file is almost pure HTML, with only the <code>{{ content }}</code> tag. When
we specify <code>default</code> as the layout inside YAML for a Markdown file,
the Markdown text is converted to HTML, and then this layout file is
wrapped around it. You can see that the initial post files specify the
<code>post</code> layout, which is wrapped around the content, then the
<em>post.html</em> layout file specifies the <em>default.html</em> layout, which is
wrapped around the entire contents.</p>
</div>
<div class="paragraph">
<p>When we add these files, the Jekyll tool will notice the filesystem has changed and regenerate files. We now have generated posts, but
we don&#8217;t have a master index file, so let&#8217;s add this now.</p>
</div>
</div>
<div class="sect3">
<h4 id="master-index-file-with-liquid-markup">Master Index File with Liquid Markup</h4>
<div class="paragraph">
<p>We now have the posts generated properly, but we don&#8217;t have an entry page into the blog. We can create an <em>index.md</em> file, which just displays an index of all the blog posts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">---
layout: default
---

&lt;h1&gt;ByTravelers.com&lt;/h1&gt;

Crowd sourced travel information.

&lt;br/&gt;

&lt;div&gt;
{% for post in site.posts %}
&lt;a href="{{ post.url }}"&gt;&lt;h2&gt; {{ post.title }} &lt;/h2&gt;&lt;/a&gt;
{{ post.content | strip_html | truncatewords: 40 }}
&lt;br/&gt;
&lt;em&gt;Posted on {{ post.date | date_to_string }}&lt;/em&gt;
&lt;br/&gt;
{% endfor %}
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that the file combines Markdown (the single <code>#</code> character
converts into an H1 tag) with regular HTML. You are free to mix
regular HTML inside of Markdown files when there is not a Markdown
equivalent.</p>
</div>
<div class="paragraph">
<p>Output tags use double braces surrounding the
content (<code>{{ site.title }}</code>) while logic tags use a brace and percent
symbol (<code>{% if site.title %}</code>). As you might expect, output tags place
some type of visible output into the page, and logic tags perform some
logic operation, like conditionals or loops.</p>
</div>
<div class="paragraph">
<p>The preceding template has both output and logic tags. We see a logic tag
in the form of <code>{% for &#8230;&#8203; %}</code>, which loops over each post. Jekyll will
process the entire posts directory and provide it to pages inside the
<code>site.posts</code> variable, and the <code>for</code> logic tag allows us to iterate
over them. If we use a <code>{% for &#8230;&#8203; %}</code> tag we need to "close" the tag
with a matching <code>{% endfor %}</code> tag. Inside of our for
loop we have several output tags: <code>{{ post.url }}</code> outputs the post
URL associated with a post, for example. We also have <em>filters</em>, which
are methods defined to process data. One such filter is the
<code>strip_html</code> filter, which you might guess strips out HTML text,
converting it to escaped text. This is necessary when your text could
include HTML tags. You&#8217;ll also notice that filters can be "chained";
we process the body with the <code>strip_html</code> filter and then truncate the
text by 40 characters using the <code>truncatewords:40</code> filter.</p>
</div>
<div class="paragraph">
<p>If we open <em><a href="http://localhost:4000" class="bare">http://localhost:4000</a></em> in our browser, we will see a
simple index page with the titles of our posts, like <a href="#austere_but_a_step_in_the_right_direction">The Index Page, for a naked Jekyll blog</a>.</p>
</div>
<div id="austere_but_a_step_in_the_right_direction" class="imageblock">
<div class="content">
<img src="images/btwg_06in01.png" alt="btwg 06in01">
</div>
<div class="title">Figure 6. The Index Page, for a naked Jekyll blog</div>
</div>
<div class="paragraph">
<p>This index page lists every post: let&#8217;s make it display only the last
10 posts. Copy the <em>index.md</em> file to a file named <em>archive.md</em>.
Then, change the <code>{% for post in site.posts %}</code> tag to <code>{% for post in
site.posts | limit:10 %}</code>.</p>
</div>
<div class="paragraph">
<p>Each post has an associated page that is generated by Jekyll.
Clicking any of the links displays the post, which is right now
just the title. We can now add the rest of the pages from our scraper.</p>
</div>
</div>
<div class="sect3">
<h4 id="scraping-body-and-author">Scraping Body and Author</h4>
<div class="paragraph">
<p>Use IRB to find the author and body content. Start by searching for the author information:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">2.0.0-p481 :037 &gt; rows[2].to_s
=&gt; "&lt;tr&gt;\n&lt;td align=\"center\"&gt;\n\n\n\n&lt;font size=\"+1\"&gt;author:..."
2.0.0-p481 :038 &gt; ( rows[2] / "td font" )[0].text()
=&gt; "author: \n\nMD \n\n\nread more from this author | \nsee maps from this..."
2.0.0-p481 :039 &gt; author = ( rows[2] / "td font" )[0].text()
=&gt; "author: \n\nMD \n\n\nread more from this author | \nsee maps from this..."
2.0.0-p481 :040 &gt; author =~ /author:\s+\n\n([^\s]+)\n\n/
=&gt; 0
2.0.0-p481 :041 &gt; $1
=&gt; "MD"</code></pre>
</div>
</div>
<div class="paragraph">
<p>We start by looking at the second row and converting it to raw HTML.
We see there is a string author:, which is a likely place to
reference the author. This string is wrapped by a font tag and a
td tag, so we can use these search queries to eliminate extra
information. Then, we convert the HTML to text using the <code>text()</code> method
and use a regular expression to pull out the text after the author:
string. If a regular expression matches and has a captured expression,
it will be held in the global variable <code>$1</code>. There is more than one
way to get this information, of course.</p>
</div>
<div class="paragraph">
<p>Next, we retrieve our body from the scraped page. Add a method called
<code><span class="keep-together">process</span>_body</code> and insert this into our processed hash:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def render( processed )
  processed['layout'] = 'post'
  filtered = processed.reject{ |k,v| k.eql?('body') } # # <b class="conum">(1)</b>
  rendered = "#{filtered.to_yaml}---\n\n" + # # <b class="conum">(2)</b>
    "### Written by: #{processed['author']}\n\n" +
    processed['body']
  rendered
end
 # # <b class="conum">(3)</b>
def process_body( paragraphs )
  paragraphs.map { |p| p.text() }.join "\n\n"
end

def run
  scrape()
  @pages.each do |page|
    rows = ( page / "table[valign=top] tr" )
    processed = {}
    processed['title'] = process_title( rows[0].text() ) # # <b class="conum">(4)</b>
    processed['creation_date'] = process_creation_date( rows[3].text() )
    processed['body'] = process_body( rows[4] / "p"  ) # # <b class="conum">(5)</b>
    author_text = ( rows[2] / "td font" )[0].text()
    processed['author'] = $1.strip if author_text =~ /author:\s+\n\n+(.+)\n\n+/
    rendered = render( processed )
    write( rendered, processed )
  end</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We need to rewrite <code>render</code> slightly. There is no need for the
entire body content of a post to be included in the YFM. We can
filter this out using the <code>reject</code> method.</p>
</li>
<li>
<p>Then, we append the author and body content to generate the new
rendered output.</p>
</li>
<li>
<p>Our process body is straightforward: we convert each node passed
into text (using the <code>text()</code> method) and then rejoin them with
double newlines. Markdown will properly format paragraphs if they are
separated by two newlines.</p>
</li>
<li>
<p>We then just need to invoke the <code>process_body</code> method and insert
the results into our processed hash.</p>
</li>
<li>
<p>Next, we use the query path we found in our IRB session to retrieve
the author information, and insert it into our processed hash. The
author name will then be inserted into our YFM automatically within
the <code>render</code> method, and we will insert it into the post.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We can then run <code>bundle exec ./run.rb</code> to rewrite our post files.</p>
</div>
</div>
<div class="sect3">
<h4 id="adding-images-to-jekyll">Adding Images to Jekyll</h4>
<div class="paragraph">
<p>Jekyll can host any binary files as well, and Markdown files can host
the proper markup to include these assets. Let&#8217;s add the images from
the original site:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def process_image( title )
  img = ( title / "img" )
  src = img.attr('src').text()
  filename = src.split( "/" ).pop

  output = "assets/images/"
  FileUtils.mkdir_p output unless File.exists? output
  full = File.join( output, filename )

  if not File.exists? full or not File.size? full
    root = "https://web.archive.org"
    remote = root + src
    # puts "Downloading #{full} from #{remote}"
    `curl -L #{remote} -o #{full}`
  end

  filename
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>We use the venerable cURL to download our images. Our code makes it so
that the file is only downloaded the first time. We use the <code>-L</code>
switch to tell cURL to follow redirects, because these images URLs are
transparently redirected inside the browser.</p>
</div>
<div class="paragraph">
<p>We need to customize our run method to invoke the <code>process_image</code> call:
add <code><span class="keep-together">processed</span>&#x5b;'image'&#x5d; = process_image( rows&#x5b;0&#x5d; )</code> after any of the
other process methods.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
I paid an artist for the images used on the original
ByTravelers.com. If you are using this technique to scrape images or
text content from another site, make sure you are abiding by all local
and international copyright laws.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Then, modify our post layout to include the image:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">---
layout: default
---

&lt;h1&gt;{{ page.title }}&lt;/h1&gt;

&lt;img src="/assets/images/{{ page.image }}"&gt;

{{ content }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Regenerating this page shows us a white background with an awkwardly
juxtaposed colored image. Adding background colors to the entire site
will help, so let&#8217;s now modify the CSS for our site.</p>
</div>
</div>
<div class="sect3">
<h4 id="customizing-styling-css">Customizing Styling (CSS)</h4>
<div class="paragraph">
<p>We used Bootstrap in <a href="#JavaScript">[JavaScript]</a> and will use it again
here. We will also layer another CSS file on top of Bootstrap to
customize the colors.</p>
</div>
<div class="paragraph">
<p>First, add a reference to Bootstrap and our custom CSS inside of the
master layout file, <em>default.html</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;html&gt;
&lt;head&gt;
&lt;title&gt;ByTravelers.com&lt;/title&gt;

&lt;link href="/assets/css/bootstrap.min.css" rel="stylesheet"&gt;
&lt;link href="/assets/css/site.css" rel="stylesheet"&gt;

&lt;/head&gt;

&lt;body&gt;

{{ content }}

&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, download the Bootstrap CSS file into the proper folder:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ mkdir assets/css
$ curl \
https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css \
-o assets/css/bootstrap.min.css</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adding a CSS framework like Bootstrap helps things considerably, but
we should match the original colors as well. Add a file called
<em>site.css</em> into the <em>assets/css</em> directory:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-css" data-lang="css">body {
color: #000000;
background-color: #CCCC99;
}

a {
color: #603;
}

.jumbotron {
background-color: #FFFFCC;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the Bootstrap library installed, we can slightly modify our
<em>default.html</em> layout to make the site really stand out. Many Jekyll
blogs are quite minimalistic and stark, but you are limited only by
your imagination:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;ByTravelers.com&lt;/title&gt;
    &lt;link href="/assets/css/bootstrap.min.css" rel="stylesheet"&gt;
    &lt;link href="/assets/css/site.css" rel="stylesheet"&gt;
  &lt;/head&gt;

  &lt;body&gt;

    &lt;div class="container"&gt;
      &lt;div class="jumbotron"&gt;
        &lt;h1&gt;ByTravelers.com&lt;/h1&gt;
        Alternative travel information
      &lt;/div&gt;
      &lt;div class='row&gt;
        &lt;div class='span12'&gt;
          &lt;div class="container"&gt;
            {{ content }}
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we reload, we will see a much prettier version of the site (<a href="#jekyll-now-livelier">Restoring the original colors and images</a>).</p>
</div>
<div id="jekyll-now-livelier" class="imageblock">
<div class="content">
<img src="images/btwg_0606.png" alt="btwg 0606">
</div>
<div class="title">Figure 7. Restoring the original colors and images</div>
</div>
<div class="paragraph">
<p>We&#8217;ve now entirely scraped an old site and built a new Jekyll blog, so
there is just one thing left to do: encourage and permit
collaboration, which GitHub makes particularly easy.</p>
</div>
</div>
<div class="sect3">
<h4 id="inviting-contributions-with-github-fork">Inviting Contributions with GitHub "Fork"</h4>
<div class="paragraph">
<p>When you publish a Jekyll blog, the fact that it is a repository on
GitHub makes it simple to manage and track changes. In addition,
because forking is a button click away, you can ask people to
contribute or make changes with very little friction.
You might have seen the banner saying "Fork me on GitHub" on many a
software project page hosted on GitHub. We can motivate others to
participate in our blog using pull requests. Let&#8217;s add that as a final touch and
invite people to make contributions the GitHub way. The <a href="https://github.com/blog/273-github-ribbons">GitHub blog
first posted these banners</a>, and we&#8217;ll use its code almost as is inside our
<em>default.html</em> page, just changing the reference to our repository in
the link tag:</p>
</div>
<div class="listingblock pagebreak-before">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">...
&lt;body&gt;

  &lt;a href="https://github.com/xrd/bytravelers.com"&gt;
    &lt;img style="position: absolute; top: 0; right: 0; border: 0;"
	   src="https://..."
	   alt="Fork me on GitHub"
	   data-canonical-src="https://.../forkme_right_gray_6d6d6d.png"&gt;&lt;/a&gt;

  &lt;div class="container"&gt;
    &lt;div class="jumbotron"&gt;
      &lt;h1&gt;ByTravelers.com&lt;/h1&gt;
      Alternative travel information
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now anyone can fork our repository, add their own post to the <em>_posts</em> directory, and then issue a pull request asking us to incorporate the new post into our Jekyll blog.</p>
</div>
</div>
<div class="sect3">
<h4 id="publishing-our-blog-to-github">Publishing Our Blog to GitHub</h4>
<div class="paragraph">
<p>Like any other GitHub repository, we can then publish our blog using
the same commands we saw with earlier repositories. Obviously you
should change the username and blog name to suit your own needs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ export BLOG_NAME=xrd/bytravelers.com
$ gem install hub
$ hub create $BLOG_NAME # You might need to login here
$ sleep $((10*60)) &amp;&amp; open http://bytravelers.com</code></pre>
</div>
</div>
<div class="paragraph">
<p>And, don&#8217;t forget to set up DNS records and give yourself appropriate
time to let those records propagate out.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="summary">Summary</h3>
<div class="paragraph">
<p>We&#8217;ve explored the details of Jekyll, looking at the structure of a
Jekyll blog. Liquid Markup is a powerful way to use programmatic
constructs inside a Markdown file, and we documented the most
important concepts around using this templating language. By
investigating the internals of a Jekyll post, we explained the
intricacies of YAML Front Matter (YFM) and how seamlessly you can mix
and match HTML with Markdown syntax. Jekyll blogs can utilize their
own custom CSS, and we&#8217;ve shown how easy it is
to use a powerful complete library like Bootstrap layered underneath a
site-specific small CSS file. And, we built a scraper application
that retrieves a remote site in its entirety and converts it into the
correct structure of a Jekyll blog. Even though this scraper application was
built specifically for a particular site, by adding testing and
properly structuring the components it should be evident how to reuse
much of the scraper for anything else you want to quickly convert into
a Jekyll blog.</p>
</div>
<div class="paragraph">
<p>In the next chapter we will continue looking at Jekyll by building an
Android application that uses the Java GitHub API bindings and allows
you to create Jekyll blog posts with the Git Data API.</p>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. This is all well documented on the <a href="https://help.github.com/articles/setting-up-a-custom-domain-with-github-pages">GitHub blog.</a>
</div>
</div>

      
      <div class="footer border-top border-gray-light mt-5 pt-3 text-right text-gray">
        This site is open source. <a href="http://github.com/xrd/BuildingToolsWithGithubBook/edit/gh-pages/chapter-05-jekyll.asciidoc">Improve this page</a>.
      </div>
      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
    
  </body>
</html>
